[{"id":0,"title":"谢晶晶-前端-社招-3年-上海","content":"#\n\nINFO\n\n📧 xiejj0912@foxmail.com\n\n🏫 安徽财经大学(计算机科学与技术专业)\n\n🗺️ CET4、CET6 掘金 https://juejin.cn/user/4306112028351885\n\n\n技术栈#\n\n * 在工作中使用HTML5，CSS3 进行布局，开发符合w3c标准的页面，能兼容绝大多数主流浏览器。\n * 熟悉PC端和移动端适配方案，使用flex/rem/@media进行响应式布局，使用less,sass等预处理器。\n * 熟练掌握原生JS 、TypeScript、 熟悉ES6语法，面向对象，JS堆栈，作用域，原型链，闭包等。\n * 熟练掌握Vue全家桶(vue、vue-router、vuex)，熟悉ant-vue, element UI，vant等UI组件库。\n * 熟练掌握React全家桶(React、react-router、 redux)，熟悉Ant Design、NutUI等UI组件库。\n * 熟悉 DataV、wangEditor、LuckySheet、SSE、WebSocket、JQuery 等前端常用技术\n * 熟悉常见性能优化方案，减少页面访问时间，提高用户体验\n * 熟练使用uni-app进行混合开发，参与完整系统上线。\n * 掌握CI/CD 自动化发布平台的部署方案、维护 Jenkins、nginx 配置。\n\n\n项目#\n\n\nePytes 综合管理平台#\n\nReact Typescript React-router Ant Design i18next Webpack5 UmiJS qiankun\n\n * 参与权限设计，对UI进⾏适配与⽇常开发、维护、优化。\n * 微前端(qiankun、wujie)基础建设、作为一个平台容器，接入多平台服务，可配置项目页面\n * 采用双 token 机制、实现 token 过期自动登录，提升用户体验；\n * 基于Ant Design二次封装组件库、采用rollup 打包组件库\n   * 封装业务组件，符合物料标准，提供物料可供后续低代码配置\n   * 维护组件库文档设计、支持多项目调用\n   * 编写维护公共工具库(类Lodash),支持多项目调用\n * 使用i18next，采用模块化方式对项目进行国际化，实现多语言功能\n * 维护公司脚手架升级\n   * webpack4升级至 webpack5，处理兼容、调优问题\n   * 参与脚手架eslint、stylelint、prettier配置升级、增加代码的可维护性\n   * 采用 swagger-axios 方案，与当前服务中 swagger 文档同步，实现 api 自动化。\n * 通过埋点设计，给予产品组有效的数据支撑\n * 发布私服nexus、维护管理平台架构架设计调整、维护脚手架文档\n * 参与部分平台页面的开发、例开发售后管理系统，独立开发 QMS 生产采集、财务日报、问题平台等\n\n> 项目成果: 推广组件库、工具库的使用，并实现文档化协作管理，提高整体开发消息 30%。\n\n\neMES 制造执行系统#\n\nVue2 ElementUI Vuex WebPack vue-router jQuery\n\n * 参与权限构建讨论，将老版本的系统，进一步升级至新版本服务。\n * 与硬件对接，读取扫码枪数据，使用 zxing 库识别条形码\n * 维护公司脚手架升级\n   * 改造 webpack 多页面设计，兼容部分 jQuery 页面的使用，进行统一的包管理。\n   * 实现 vue-cil 调优问题(例如 gzip、外部cdn、分片打包等)。\n   * 合并脚手架多种语言的切换处理。\n * 参与项目 CI/CD 自动化部署的方案讨论，维护 nginx 配置管理，参与 jenkins 打包指令的完善。\n\n> 项目成果: 深入了解 webpack 的构建、改造 jQuery 老版本代码，提高项目的可维护性，代码访问速度提高 30%。\n\n\n派智数字化监控中心#\n\nVue2/3 DataV Echarts Echarts WebPack\n\n * 调研大屏展示方案\n   * 调研媒体查询、pxtoRem 等转换方案\n   * 采用minx方法，监听屏幕，使全屏容器将根据屏幕比例及当前浏览器窗口大小，自动进行缩放处理。\n * 可视化数据组件封装\n   * 将常用Echarts图进行封装，方便业务调用。\n     * 调研svg动画效果、协调配合 UI 制作出部分定制化动效\n     * 参考开源项目go-view、当组件沉淀后可以可以对应配置\n * 优化项目中的代码，提升项目的提升项目健壮性。\n   \n   * 采用虚拟列表的方式，构建 table 组件封装，优化由于大数据产生的卡顿\n   \n   * 针对大屏项目嵌套过多的组件进行拆分和重新设计，减少了渲染次数和逻辑复用问题\n   \n   * 利用axios的拦截器过滤重复请求,解决业务中出现短时间内多次调用的问题。\n\n\nai 智能分析平台#\n\nReact Dify flow\n\n * 调研市面上已知大模型设计方案，进行性能测试反馈、价格指标的统一处理。\n * 采用 docker compose 部署 Dify 服务。\n * 采用 rap 对于市场上已知网站的关键信息指标获取。\n * 采用向量数据库构建知识库。\n * 通过工作流的构建，完成工作流的提示词的构建。\n * 构建公司市场分析、财务分析领域的工作模型。\n * 开发聊天对话框，对接聊天窗、工作流，形成组件化配置，可供配置至内部脚手架环境。\n\n\n工作经历#\n\n\n上海派智能源股份有限公司(2022.06-至今)#\n\n * 参与前端组件库、脚手架、参与并主导ePytes 、eMES、监控中心、CRM的设计与维护\n\n\n教育背景#\n\nINFO\n\n安徽财经大学(计算机科学与技术专业) 2018.09 – 2022.07","routePath":"/about/","lang":"","toc":[{"text":"技术栈","id":"技术栈","depth":2,"charIndex":116},{"text":"项目","id":"项目","depth":2,"charIndex":599},{"text":"ePytes 综合管理平台","id":"epytes-综合管理平台","depth":3,"charIndex":605},{"text":"eMES 制造执行系统","id":"emes-制造执行系统","depth":3,"charIndex":1291},{"text":"派智数字化监控中心","id":"派智数字化监控中心","depth":3,"charIndex":1672},{"text":"ai 智能分析平台","id":"ai-智能分析平台","depth":3,"charIndex":2094},{"text":"工作经历","id":"工作经历","depth":2,"charIndex":2337},{"text":"上海派智能源股份有限公司(2022.06-至今)","id":"上海派智能源股份有限公司202206-至今","depth":3,"charIndex":2345},{"text":"教育背景","id":"教育背景","depth":3,"charIndex":2422}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"1.自定义可编辑表格的单元格","content":"#\n\n好久都没写过掘金文章了，失恋一场，颓废了很久，想来还是找点事做，写写知识点记录一下。\n\n工作中真是频繁用到可编辑表格，最近一次的需求，让我把这个彻底搞明白了。\n\n- 1、合并单元格 这个合并单元格也是常出现的需求，column里面有一个onCell的api可以实现。 我这里合并的条件是id不同且值相同\n\n\n\n效果：\n\n\n\n- 2、自定义单元格 有一个需求是，数值型的需要根据抽样数去生成输入框，且动态更新不良数，文字类型就显示一个textarea。这样就需要自定义单元格了\n\n只读模式\n\n\n\n\n\n编辑模式下\n\n其实文档里写的很清楚，只读模式的时候用render去设置单元格，编辑模式下用renderformitem去设置单元格。最开始我没搞懂这点才像个没头苍蝇一样乱转。\n知道这两个api的作用后，代码就很简单了，在renderformitem的时候去调用自定义的组件，render只读下遍历，给每个采集值加上边框：\n\n\n\n自定义组件的时候，value和onchange是自动包裹的，不需要手动去传入。 这里有两个问题因为时间比较紧急还没好好去解决：\n1、renderFormItem传入的参数的类型定义，总是报错，看源码的定义是这样的\n2、第二点就是遍历的时候key的选择，因为遍历的采集值也只是逗号分割的数字字符串而已，没有给唯一的id表示，用index又总是报错，最后采用了时间戳。\n\n仔细阅读文档才发现文档上那个例子已经写的非常清晰明了了，还是要多读文档。\n\n","routePath":"/antd-design/editableProTable/1.自定义可编辑表格的单元格","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"","content":"最近有一个需求是可编辑表格里需要自定义组件，比如可多选的select，遇到了很多问题，编辑的时候数据需要反显，valueEnum的类型，renderFormIt\nem的写法等等，EditableProTable已经能满足了很多需求，但是文档有点点难看懂。\n\n如果是单选下拉框的话可以写valueType:'select'，我想要多选的select，chatGPT居然告诉我这样写：valueType:'select-m\nultiple'……不知道他从哪儿学习到的，反正是错误的写法……\n\nEditableProTable的示例代码如下：\n\n\n\n这样写EditableProTable里面就可以有多选的select了。这只是一个简单的例子\n后面还要写的更复杂一点、对一点接口，可编辑表格感觉还是挺常用的，但是其中的api都不是很熟。\n\nantd\npro的很多组件封装的都挺好的，使用起来比antd的舒服，但是也存在着过度封装的问题，我以前用proformlist嵌套proformlist的时候就出现了第二\n层的actionRef失效的问题，每次改第二层的数据，只能从第一层中解构出来，还是很麻烦的（不过也比写俩formlist嵌套要好点。）","routePath":"/antd-design/editableProTable/2.有多选的select以及其反显问题","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"","content":"emmm之前写了两篇可编辑表格，结果使用起来还是有点小bug，在antd官方和同事的帮助下，终于get到了EditableProTable正确的使用方式，bug\n也都解决了。\n\n下面的代码可以通过EditableProTable完成部门和人员的联动，也可以控制是否可编辑等。\n部门选择之后，会请求接口加载该部门下的人员数据，如果修改部门的话，已经选中的人员也是要清空的。\n\njs\n\n代码解读\n\n复制代码\n\n//return里面的 可编辑表格外面没有加一层form，直接通过value和onChange赋值的。 <EditableProTable\nrowKey=\"id\" value={dataSource} onChange={(values) => { setDataSource(values); }}\neditableFormRef={editorFormRef} actionRef={actionRef} scroll={{ x: 'calc(800px +\n80%)' }} columns={columns} size=\"large\" recordCreatorProps={{ position:\n'bottom', record: (index: number) => { return { id: index.toString(), //id\nstring类型，最好不要写随机数。 }; }, disabled: loadings, //控制添加一行的那个按钮是否显示 hidden:\n!(flowActivityId == 'task_qlty_error_ycgs' && flowInProcess), }} editable={{\ntype: 'single', editableKeys, onChange: setEditableRowKeys,\nonlyAddOneLineAlertMessage: '请保存后再新增！', actionRender: (_, __, defaultDom) => {\nreturn [defaultDom.save, defaultDom.cancel]; //只保留了保存和取消的按钮 }, }} />\n\njs\n\n代码解读\n\n复制代码\n\n//column里面写的部分内容，主要是责任部门和责任人的联动，选择责任人之后 { title: '责任部门', dataIndex:\n'responsibleDeptId', key: 'responsibleDeptId', width: '18%', align: 'center',\nformItemProps: { rules: [{ required: true, message: '请输入责任部门' }], }, valueType:\n'treeSelect', valueEnum: Object.fromEntries( [...deptName.current].map(([key,\nvalue]) => [key, { text: value }]), ), editable: () => flowActivityId ==\n'task_qlty_error_ycgs' && flowInProcess,\n//在fieldProps里面去写valueType中确定的组件的属性，可以获取到该行的数据。 fieldProps: (_, { rowIndex }) =>\n{ return { options: treeSelect, treeExpandedKeys: expandKeys, onTreeExpand:\n(expandedKeys) => { setExpandKeys(expandedKeys); }, onChange: (value: number) =>\n{ //这个是完成部门人员联动的函数 selectPerson(value, rowIndex); //这里有坑\neditorFormRef.current?.setRowData?.(rowIndex, { responsibleId: undefined });\n//清空之后触发表单验证 setTimeout(() => { editorFormRef.current?.validateFields(); },\n100); }, treeLine: true, }; }, }, { title: '责任人', dataIndex: 'responsibleId',\nkey: 'responsibleId', width: '12%', valueType: 'select', formItemProps: { rules:\n[{ required: true, message: '请输入责任人' }], }, editable: () => flowActivityId ==\n'task_qlty_error_ycgs' && flowInProcess, valueEnum: () => { return\nObject.fromEntries([...peopleMap].map(([key, value]) => [key, { text: value\n}])); }, fieldProps: (_, { rowIndex }) => { return { options:\npeopleOptionArr[rowIndex], }; }, align: 'center', },\n\n这里的坑就在于我想要清空掉责任人的数据时，用了这个setRowData函数editorFormRef.current?.setRowData?.(rowInde\nx, { responsibleId: undefined });\n\n\n\n然后我id之前是用随机数设置的，根据行号去清空数据是有问题的,debug了很久。后来规范了id之后，根据行号和id去清空都可以了。之前自定义组件这样写也是可以的\n。\n\n","routePath":"/antd-design/editableProTable/3.正确使用方式","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"介绍","content":"#","routePath":"/antd-design/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"","content":"在开发中，如果有展示公司层级、学科系统、分类目录的需求的话，就经常会需要将对象数组的结构转成树型结构，然后应用到antd组件里，比如Tree树形控件、TreeS\nelect树形选择器、树形数据展示的Table等。\n\nTree\n\nTreeSelect\n\nTable\n\n只需要将数据转换成如下结构即可：\n\n\n\n转换之前就是一普通对象数组\n\n\n\n递归遍历，时间复杂度可能略高，但是我这里数据层级不超过三四层，所以还好。转换的代码如下：（转换成table需要的树形数据）\n\n\n\n写的很烂，大佬如果有修改意见，请尽管提出。\n\n如果想要table的树形结构在第二列展开可以加一行，不过文档中好像没有给出 expandIconColumnIndex={1}\n\n\n\n总结：对象数组扁平化转成树形结构这个算法还挺常用的，还可以继续优化一下，不用递归，时间复杂度太高，还可以提取出来做成一个通用的函数。","routePath":"/antd-design/tree/1.树结构的组件总结","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"","content":"之前说的做做公司组织架构树的时候用到了tree组件，现在有两个改动：\n\n * tree节点可选择，但是antd提供的是多选，没有单选的，所以要把原组件改成单选。\n * 树展开的时候太长了，需要对树的展示高度进行限制。\n\n> tree组件有一个很好用的东西是onCheck、onExpend函数传入值里面有节点信息，这个信息很重要。 function(checkedKeys,\n> e:{checked: bool, checkedNodes, node, event, halfCheckedKeys})\n\n\n\n\n一、tree组件改成单选#\n\n这个其实并不难，虽然antd没有提供，但是可以自己进行改造。改造起来也很容易：\n\n1、是把样式改了，因为传统的checkbox，方框都是表示多选，圆框是单选，其实就是加个border-radius样式\n\n\n\n改造成↓\n\n\n\n代码：\n\n\n\n二是通过逻辑实现单选，一行代码搞定，用点击的节点的key直接替代掉原来的checkedkey数组。\n\n\n\n\n二、限制树高#\n\n有两种办法：\n\n 1. tree的层级是公司-事业处-部门-子部门。同一个部门只能展开一个，也就是有一个展开的时候，点另外一个节点时，原结点收起，现点击的结点展开。\n 2. 对容纳tree的容器进行高度限制，tree高度超过容器时，展示滚动条。\n\n第一种\n\n第二种\n\n第二种办法很简单 加个样式即可style={{ height: 200, overflow: 'auto ' }}\n\n第一种代码如下，有e.node.pos、e.expanded的信息就非常好写：\n\n\n\n最开始我不知道有传入的e记录了节点的展开、层级等，然后我就在死做，记录展开的旧值，和新值做对比，得出展开还是收起，以及展开的节点，然后再写些逻辑。\n\n我们第一层的key是c0、c1，第二层的key是c0-m0,c0-m1，第三层部门的key是number类型的id（类似23、29这样的）…我就按照这个规律死做\n，最后意识到部门底下还有层级\n还有子部门，这样写完全不行emmm…没有规律，因为部门和子部门都是number类型id毫无规律，不好控制，其实有上述那么简单的做法，我自己瞎搞这么复杂。\n\n我一开始还觉得treeNode给的api太少了，给我一个字段加层级多好，想不到官方已经做好了层级的记录- -\n\n\n\n（在犯蠢= =ifelse工程师）\n\n总结下来还是要仔细的看文档，灵活应用，害= =白白浪费时间写错误的做法，记录下来，以后不走弯路。","routePath":"/antd-design/tree/2.改成单选&同一层级只能展开一个（点击一个节点时另一个展开节点收起）","lang":"","toc":[{"text":"一、tree组件改成单选","id":"一tree组件改成单选","depth":3,"charIndex":256},{"text":"二、限制树高","id":"二限制树高","depth":3,"charIndex":444}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"9、最后还有一个待解决的问题。","content":"使用antd的一些小问题#\n\n好久没写笔记，记录一下最近项目遇到的小知识点，有的是问chatGPT的，挺好用，有时候比自己翻文档快一点。\n\n\n1、table为空时的empty组件可以自己修改样式，需要用到的api是table的locale#\n\n\n\n\n2、一个页面上有20个表格，对表格的pageSize，pageNumber，total等进行管理#\n\n定义变量的时候需要确定其长度并且初始化\n\n\n\n\n3、table第一列是checkbox，选中一页的key之后再翻页，之前选的key不会丢失#\n\n需要用到preserveSelectedRowKeys:\ntrue,。这个属性在官方文档上的解释是当数据被删除时仍然保留选项的 key，源码里其实有这样的解释/** Keep the selection keys in\nlist even the key not exist in dataSource anymore */\n意思应该就是我们page的值变了->会调一次接口->dataSource的data值会变化，之前选的key已经不在新的dataSource里面了，preserv\neSelectedRowKeys为true时可以保存住以前选了但是不在现在dataSource的key值\n\n\n\n\n4、一个需求，点击开始按钮，加载数据的时候，显示一个圆形进度条用来展示加载数据的进度。#\n\n\n\n（截图只截了一点，所以看起来progress没有居中）\n\n分析这个需求，感觉应该用一个modal里面加一个progress组件就可以完成的，但是最重要的是修改modal的样式，使modal能够遮罩住整个页面。\n\n\n\n\n\n其实样式看着没多少，但是我调了好久，浪费了很多时间，害。\n\n\n6、一个页面有一个table，每列都需要跳转，render要写很多遍，封装一个函数解决#\n\n\n\n\n\n\n8、浏览器空格#\n\n浏览器会将文字前后的空格省略，文字中连续的空格会合并成一个空格。 导致的问题：直接复制做查询条件时查询不到表格数据。\n解决1:重新render渲染一遍，将其包裹在<pre>标签中，该标签会保持字符串原样输出，不会对空格进行修正，但是自带的样式也会消失，且不能换行。\n解决2:style中设置whiteSPace的值为pre-wrap，可以正常换行且保留样式。\n\n\n\n以上都是自己的摸索，不知道有没有更好的解决办法，\n\n\n9、最后还有一个待解决的问题。#\n\n两个列表并列，一个五条数据一个十条数据，看着页面不好看，不知道该怎么调整比较好呢？\n\n","routePath":"/antd-design/使用antd的一些小问题","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"后台管理，用select组件获取antd全部icon并进行选择，该怎么做？","content":"#\n\n最近在写后台管理系统，其中有一个选择菜单icon的功能，需要加载出antd的所有icon然后进行选择，效果如下：\n\n\n\n加上模糊查询：\n\n\n\n在掘金找到一位小伙伴的实现方法，不过他是用select，他的文章链接如下： juejin.cn/post/712314…\n\n我用的是ProFormSelect，没有采取jsx写option的方式。 代码如下：\n\n\n\n使用ProFormSelect代替Select组件不仅仅是因为有label更方便，而且还有，在使用上面那位小伙伴的代码\n\n\n\n这个对proformselect不起作用，所以我就放弃了jsx的写法，直接再遍历一遍iconList生成option，这样应该效率也更高一点。\n\n\n\n总结：带脑子的进行cv操作，多看文档，多看其他大佬的代码，很多问题都能迎刃而解，over。","routePath":"/antd-design/后台管理-用select组件获取antd全部icon并进行选择，该怎么做","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"响应式栅格化布局","content":"#\n\n今天完成的一个需求：某个功能会在手机和电脑上使用，所以需要做适配。完成这个功能用的是antd mobile的组件，但是我加需求的时候没注意，直接用了antd\ndesign的row和col，没有用antd\nmobile的Grid、Grid.Item，懒得换了，仔细看了看文档其实col也可以响应式，以前只用过row的gutter。\n\n\n\n效果如下： 移动端：\n\n\n\nPC端：\n\n\n\n\n\nrow和col还是很好用的","routePath":"/antd-design/响应式栅格","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"环境变量工程化","content":"#\n\n前端的环境变量用的最多的大概就是根据不同的环境去打包，不用一个个修改ip。\n\n\nantd pro umi的环境变量。#\n\n创建一个UMI_ENV的环境变量，根据这个变量打包生产不同的dist文件，同时在浏览器标签上标注是测试环境还是开发环境。\n\n创建三个config文件\n\n\n\n创建三个config文件\n\nProLayout自定义title\n\n\n\ntitle变了\n\n\n\n\nvue2项目的环境变量#\n\n也是在package.json对应命令里添加环境变量，然后添加对应的.env文件 VUE*APP_API_URL=api.example.com\n（以 VUE_APP* 开头的变量会被Vue\nCLI自动注入到应用程序的 process.env 中，在Vue组件或代码中，可以通过 process.env.VUE_APP_API_URL 访问这个环境变量\n的值。）\n\n还是直接看vuecli的官方文档更有性价比……\n\n\n\n","routePath":"/antd-design/环境变量工程化","lang":"","toc":[{"text":"**antd pro umi的环境变量。**","id":"antd-pro-umi的环境变量","depth":2,"charIndex":-1},{"text":"**vue2项目的环境变量**","id":"vue2项目的环境变量","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"AI大模型应用调研-Dify部署","content":"#\n\n最近一直在调研AI应用，也在不断测试各家大厂的产品。下面个人拙见，希望有更懂的大佬可以指点一下。\n\n\n我将市面上的AI应用大致分为三类：#\n\n1、大模型应用，基于某种大模型搭建的ai问答机器人，可以进行多轮对话、角色设定、上传文件进行分析，甚至联网搜索等。比如Kimi、文心一言、豆包、通义千问、GPT\n等。\n\n2、AI Agent应用开发平台，有知识库搭建、工作流编排等功能，核心服务是为用户提供一个快速开发AI应用的平台，本质是“低代码”构建AI\nBot。比如扣子coze、Dify、千帆、钉钉AI助理、BetterYeah AI、天工SkyAgents、智谱清言等。\n\n3、提供模型精调的平台，用户可以基于平台基础模型，上传数据集，创建精调任务，比如字节的火山方舟、阿里的百炼等平台。这些平台非常大而全，是一站式的大模型开发及应用\n构建平台。\n\n这些平台基本都用了个遍，给领导输出了几份调研报告（累），基于个人的使用经验，不甚严谨，有需要的朋友可以私信我。最后领导决定本地化部署Dify。Dify是一个开源\n的基于大语言模型的AI应用开发平台，可以部署在本地，但是使用的大模型服务还是要在对应模型官网获取API\nKEY，并且购买API调用额度。已支持主流的模型供应商，例如 OpenAI的GPT\n系列、Anthropic的Claude系列等。不同模型的能力表现、参数类型、价格都不一样。构建AI应用的流程和coze基本一致。可以嵌入到网页上，制作拥有业务数\n据的官网 AI智能客服。\n\n\n接下来是Dify的部署流程：#\n\n官网上对部署服务器的要求只有- CPU >= 2 Core、- RAM >= 4\nGiB，但是最最最重要的是！服务器能访问外网！这一点导致我找了好久bug，都没有解决，甚至想反复重装系统。一定需要海外服务器。必备。\n\n接下来就是在服务器上安装docker和docker compose（版本要求：Docker 19.03 or later Docker Compose 1.28\nor later） 我按照这个教程安装的 blog.csdn.net/justlpf/art…\n过程非常简单，最后检查一下版本就可以。遇到的难解决的bug是关于docker镜像库的，最近有很多docker镜像库都挂了，在找教程的时候需要注意发布时间。\n\n之后就是跟着dify官网进行本地部署（官方文档：docs.dify.ai/zh-hans/get…\n）如果顺利的话，完全不需要修改.env和docker_compose.yaml的（需要修改域名和数据库配置的另说）\n\n启动成功之后就是进行大模型API KEY的配置，配了一圈豆包是最难整的。\n\n\n\n配置完之后就是对Dify工作流的继续探索了。","routePath":"/dify/AI大模型应用调研-Dify部署","lang":"","toc":[{"text":"我将市面上的AI应用大致分为三类：","id":"我将市面上的ai应用大致分为三类","depth":2,"charIndex":53},{"text":"接下来是Dify的部署流程：","id":"接下来是dify的部署流程","depth":2,"charIndex":649}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"生成PPT并导出","content":"#\n\n * 在AI迅速发展的现在，身为前端工程师也要学习AI，跟上技术潮流，保持自身竞争力。\n * 本文会分享一个DIFY工作流，完成了 市场分析->生成PPT->总结内容和标题->发送邮件\n   的流程，使用的技术：node写后端接口、dify制作工作流、marp将md转换成PPT。当然，这样的流程也存在缺陷，后续也换了其他的技术，接下来会一一说明\n   。\n\n\n\n\n1、DIFY部署#\n\n使用DIFY官网提供的云端DIFY存在很多的限制，例如只有单工作空间、工作空间最多10个项目、知识库容量限制等。所以我们可以在自己的服务器上部署DIFY，这样私\n有化部署，数据的安全性也得到了提高。DIFY的部署、为什么会选择DIFY，这些问题在上一篇文章中有详细描述。\n\n\n\n\n2、引入大模型#\n\ndify支持的大模型非常多，我使用的是kimi联网搜索版，kimi每人有15的免费额度，像豆包、文心、智谱等都有免费的额度，测试的时候可以先用免费的。\n调用kimi接口有两点注意事项，一是使用网络搜索需要自己加上tools\n$web_search，二是如果需要kimi输出json格式的数据，需要指定一下response_format\n\nnode接口示例如下：\n\njs\n\n代码解读\n\n复制代码\n\nconst openai = require('openai'); // 需要安装 openai 库 const { kimiConfig } =\nrequire('../config/kimi'); const client = new openai.OpenAI({ apiKey:\nkimiConfig.apiKey, baseURL: kimiConfig.baseURL, }); const tools = [ { type:\n'builtin_function', function: { name: '$web_search', }, }, ]; class\nKimiReqService { constructor() { this.client = new openai.OpenAI({ apiKey:\nkimiConfig.apiKey, baseURL: kimiConfig.baseURL, }); } async kimiReq(content,\nisJSON = false) { let finishReason = null; let tool_result = null; let\nfinalResponse = ''; const messages = [ { role: 'system', content:\n'你会为用户提供安全，有帮助，准确的回答。同时，你会拒绝一切涉及恐怖主义，种族歧视，黄色暴力等问题的回答。', }, { role: 'user',\ncontent: content }, ]; while (finishReason === null || finishReason ===\n'tool_calls') { const completion = await client.chat.completions.create({ model:\n'moonshot-v1-auto', messages: messages, temperature: 0.3, tools: tools,\nresponse_format: isJSON ? { type: 'json_object' } : { type: 'text' }, }); const\nchoice = completion.choices[0]; finishReason = choice.finish_reason; if\n(finishReason === 'tool_calls') { messages.push(choice.message); for (const\ntoolCall of choice.message.tool_calls) { const tool_call_name =\ntoolCall.function.name; const tool_call_arguments =\nJSON.parse(toolCall.function.arguments); if (tool_call_name === '$web_search') {\ntool_result = tool_call_arguments; } else { tool_result = 'no tool found'; }\nmessages.push({ role: 'tool', tool_call_id: toolCall.id, name: tool_call_name,\ncontent: JSON.stringify(tool_result), }); } } else { finalResponse =\nchoice.message.content; } } return finalResponse; } } module.exports = new\nKimiReqService();\n\n\n3、DIFY HTTP节点调用注意事项#\n\nPOST请求的form-data使用下来貌似有bug（有成功的朋友可以说一声），所以我选择用JSON传递参数。大模型输出的body也是string类型，我们需要\n对输出结果进行转换，然后才可以直接调用。\n\n\n\n\n\n\n4、PPT生成#\n\nPPT生成，我使用的是Marp，如果有用过的朋友会知道，Marp是基于 Markdown 的开源幻灯片制作工具，可以轻松将 Markdown\n文档转换为精美的幻灯片，输出格式可以是HTML、PPTX、PDF。当然Marp有一个致命的缺点就是，他输出的PPT是不可编辑的，和直接编辑PPT有本质的区别。（\n为了生成可编辑的PPTX文件，后续换了一个PPTist的方案，开发完成后会输出文档，欢迎一起交流。）\n\n所以，接着之前的工作流，这一步会将得到的分析内容，接下来需要转换成md格式，方便Marp去输出PPT（提示词需要多调试调试）。\n\nMARP使用示例：\n\njs\n\n代码解读\n\n复制代码\n\nconst path = require('path'); const fs = require('fs').promises; const {\nexecSync } = require('child_process'); class generateService { async\ngeneratePPT(content, type = 'pptx') { try { const result = await\nthis.marpPPT(content, type); return result; } catch (error) {\nconsole.error('生成PPT错误:', error); throw error; } } async marpPPT(content, type =\n'pptx') { const timestamp = Date.now(); const mdFileName =\n`slides_${timestamp}.md`; const outputFileName = `slides_${timestamp}.${type}`;\n// 设置目录路径 const baseDir = process.cwd(); const mdDir = path.join(baseDir,\n'public/markdown'); const outputDir = path.join(baseDir, 'public/ppt'); let\nmdPath = null; let outputPath = null; try { // 创建目录 await fs.mkdir(mdDir, {\nrecursive: true }); await fs.mkdir(outputDir, { recursive: true }); mdPath =\npath.join(mdDir, mdFileName); outputPath = path.join(outputDir, outputFileName);\n// 写入markdown内容并等待完成 await fs.writeFile(mdPath, content, 'utf8');\nconsole.log('Markdown文件已创建:', mdPath); // 确认文件存在 const stats = await\nfs.stat(mdPath); console.log('Markdown文件大小:', stats.size); // 使用 execSync 执行命令\ntry { const cmd = `npx --no @marp-team/marp-cli \"${mdPath}\" --pptx -o\n\"${outputPath}\" --chrome --no-sandbox --disable-setuid-sandbox`;\nconsole.log('执行命令:', cmd); const output = execSync(cmd, { cwd: baseDir, timeout:\n600000, stdio: 'pipe', }); console.log('命令执行输出:', output.toString()); } catch\n(execError) { console.error('命令执行错误:', execError); console.error('错误输出:',\nexecError.stderr?.toString()); throw new Error(`PPT转换失败: ${execError.message}`);\n} // 确认输出文件存在 await fs.access(outputPath); console.log('PPT文件已生成:', outputPath);\n// 读取生成的文件 const fileContent = await fs.readFile(outputPath);\nconsole.log('PPT文件大小:', fileContent.length); return { mdPath, filePath:\noutputPath, fileContent, }; } catch (error) { console.error('详细错误:', error);\nthrow new Error(`生成PPT失败: ${error.message}`); } } async cleanUp(path, mdPath) {\nif (path) { fs.unlink(path).catch((e) => console.error('清理PPT文件失败:', e)); } if\n(mdPath) { fs.unlink(mdPath).catch((e) => console.error('清理MD文件失败:', e)); } } }\nmodule.exports = new generateService();\n\n\n5、发送邮件#\n\nDIFY有发送邮件的工具，但是这个工具不支持邮件名有_\n等特殊符号的，所以只能用nodemailer手搓一个发送邮件的接口。在发送之前，需要大模型总结一下邮件的标题和正文内容，最后标题、正文、附件PPT一同发送至目标\n邮箱。\n\njs\n\n代码解读\n\n复制代码\n\nconst sendEmailService = require(\"../service/email\"); const path =\nrequire(\"path\"); const emailController = async (req, res) => { if\n(!Array.isArray(req.body.emails)) { return res.json({ success: false, message:\n\"emails 必须是数组\", }); } const body = { emails: req.body.emails.join(\",\"), subject:\nreq.body.subject || \"主题\", text: req.body.text || \"正文\", attachments:\nreq.body.attachments || [ { filename: \"test.txt\", // 附件文件名 path:\npath.join(__dirname, \"../../public/ppt/test.txt\"), // 附件路径 }, ], }; // 邮件选项\nconst mailOptions = { from: \"1342980924@qq.com\", // 发件人地址 to: body.emails, //\n收件人地址 subject: body.subject, // 邮件主题 text: body.text, // 邮件正文 attachments:\nbody.attachments, }; try { await sendEmailService(mailOptions); return\nres.json({ success: true, message: \"邮件发送成功\", }); } catch (error) { return\nres.json({ success: false, message: error, }); } }; module.exports = {\nemailController, }; //services const nodemailer = require(\"nodemailer\"); const {\nsmtpConfig } = require(\"../config/email\"); class EmailService { constructor() {\nthis.transporter = nodemailer.createTransport(smtpConfig); } async\nsendEmail(mailOptions) { return new Promise((resolve, reject) => {\nthis.transporter.sendMail(mailOptions, (error, info) => { if (error) { return\nreject(\"发送失败: \" + error); } return resolve(\"邮件发送成功: \" + info.respons); }); }); }\n} module.exports = new EmailService();\n\n\n6、总结#\n\n这是一个前后端和工作流结合开发的尝试，要到生产环境中跑起来还有许多的问题，例如：\n\n * 开头分析的结果可以再跑一个工作流输出更详细、更准确的内容；\n * 大模型输出md文档也许会有问题导致PPT不能正确分页；\n * 大模型输出内容过少，PPT留白太多；\n * Marp接口部署在服务器上需要正确配置无头浏览器；\n * dify部署对服务器要求较高；\n * dify社区版还有很多bug等。","routePath":"/dify/ai-ppt/1.生成PPT并导出","lang":"","toc":[{"text":"1、DIFY部署","id":"1dify部署","depth":2,"charIndex":185},{"text":"2、引入大模型","id":"2引入大模型","depth":2,"charIndex":336},{"text":"3、DIFY HTTP节点调用注意事项","id":"3dify-http节点调用注意事项","depth":2,"charIndex":2166},{"text":"4、PPT生成","id":"4ppt生成","depth":2,"charIndex":2296},{"text":"5、发送邮件","id":"5发送邮件","depth":2,"charIndex":4711},{"text":"6、总结","id":"6总结","depth":2,"charIndex":6216}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"市场分析-AIPPT","content":"#\n\n接着上篇的AIPPT继续，我们换的第二种方案是PPT低代码设计器+DIFY工作流的形式，用到的技术栈：Vue3、Typescript、Express。流程是：运\n用DIFY工作流的多轮对话和用户交流-》市场分析-》生成PPT大纲市和具体内容-》生成json-》在线编辑PPT-》导出PPT文件。\n\n项目基于PPTist写了后端服务（因为PPTist是纯前端的，需要加上后端支持），前端加了路由和接口请求，套了一层对话框，目前可以实现AI搜索网络内容后，自动生\n成PPT，且可在线编辑PPT文档，可在固定位置生成图表，可直接导出发送到邮箱。\n\n效果如下：\n\n\n\n\n\n\n\n\n\n这种DIFY与前后端结合，把AI灵活嵌入到我们的前后端项目中的方式，也是我觉得现在的AI项目最好的应用。因为DIFY能够简化数据管理和处理，集成了多种AI工具，\n前端可以通过API直接调用工作流，和DIFY进行交互，后端可以专注于业务逻辑处理，也可以写接口让dify调用。虽然，现在的agent平台大多数都提供iframe\n嵌入网页的功能，但这样并不灵活，有很多限制，所以最好还是自己去写聊天框接入。\n\n\n\n\nPPTist#\n\nPPTist是Github上一个6.3k star的开源前端项目github.com/pipipi-pika…\n\n每一页PPT，其实都是一个json格式的Slide数组。每一个PPT元素，都通过JSON进行精确控制和定制。这样结构化的方式，可以很方便地生成、修改和保存PPT\n文件。每一个Slide对象都可能包括：幻灯片的标题、内容、样式、布局、动画，图片、视频、图表等元素都可以通过定制json对象来完成，项目中TS文件也很明确地规定\n了类型，可以仔细看一下。\n\n示例：官方默认PPT页面，这个页面通过@/src/mocks/slides.ts文件里的slides对象数组控制。\n\n所以我们的AIPPT的思路，就是让ai去生成这个json对象，我们拿到json之后就可以直接渲染出PPT进行在线编辑。\n\n\n\n\n\n\n\n\nDIFY工作流#\n\n我们在项目的前端调用DIFY工作流的API，工作流大致如下图所示，本来还希望加上知识库联合搜索，因为dify自带的知识库不太好用，所以知识库的技术方案还在考虑中\n。\n\n\n会话变量#\n\nDIFY里面有一个会话变量，可以存储读写一些上下文数据，借助这个，我们和用户进行对轮对话。本文中的应用就是记录大纲内容，通过会话的方式可以对大纲进行反复的修改。\n\n\n问题分类器#\n\nDIFY中的问题分类器可以帮助我们做意图识别，在对话中判断用户的意图，然后走对应的流程，本工作流会判断用户是从零开始生成大纲，还是要修改PPT大纲，还是需要直接\n生成PPT文件。\n\n\n\n\n联网搜索#\n\n在撰写大纲内容的时候，我们需要从网络获取数据，用到了Moonshot联网搜索的API，这个功能DIFY的LLM结点并不支持，所以需要我们自己添加HTTP结点，调\n用后端写好的联网搜索接口。\n\n\n\n\n\n\n生成JSON格式的PPT元素#\n\n大模型在输出JSON格式的回复的时候，经常会报错，要注意max-token的设置，json过长时会被截断，这样获取的json在转换时会报错。很多大模型都有指定输\n出格式的功能，比如moonshot可以指定输出json_object，但是在实际使用的时候，发现moonshot在输出json的时候还是有很多问题，最后决定用g\nlm-4-plus，通过细化提示词的方式，尽量让大模型输出一个PPT的json格式。\n\n\n\n\n\n由此可以看出来，聊天框我们可以设计为为多种类型的，img、text、json、loading等。\n\n\nPPT内容生成#\n\n后端在收到json格式的内容之后，经过格式转换和解析，一页页生成PPT元素，\n\n\n\n其中一步是生成图表，我的做法是图表独立于大纲，单独生成，之后再嵌入到PPT的固定位置。比如在PPT的结尾，加上对市场的预测数据。如果有固定的工作流的话，可以在每\n个位置都判断一下是否有足够的数据，支持图表生成。\n\n其实图表的生成有很多的方式：\n\n 1. DIFY支持直接输出echarts图表；\n 2. 让大模型直接给svg代码；\n 3. 本文给出的，生成一个PPT图表元素。等等。\n\n主要的问题是缺数据支撑，而且不能保证大模型给的数据的准确性，这才是最头疼的地方。所以我们才会考虑做知识库，数据从网络和知识库两个地方抓取。\n\n最后，项目还有很多需要优化的地方，连接本地知识库、图表的优化、PPT内容的优化、token消耗量等等，很多地方都有坑，感兴趣的朋友可以一起聊聊，后面准备做多工作\n流的集成，求大佬指导。感谢。","routePath":"/dify/ai-ppt/2.市场分析-AIPPT","lang":"","toc":[{"text":"PPTist","id":"pptist","depth":2,"charIndex":493},{"text":"DIFY工作流","id":"dify工作流","depth":2,"charIndex":862},{"text":"会话变量","id":"会话变量","depth":3,"charIndex":957},{"text":"问题分类器","id":"问题分类器","depth":3,"charIndex":1047},{"text":"联网搜索","id":"联网搜索","depth":3,"charIndex":1149},{"text":"生成JSON格式的PPT元素","id":"生成json格式的ppt元素","depth":3,"charIndex":1257},{"text":"PPT内容生成","id":"ppt内容生成","depth":3,"charIndex":1535}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"AIPPT的架构设计说明","content":"#\n\n\n1. 引言：AI与前端的融合#\n\n随着人工智能技术的快速发展，大模型逐渐成为前端开发的新趋势。作为前端开发者，我们不仅要关注代码实现，更要从架构层面思考如何将大模型与前端技术相结合，以实现更高效\n、更智能的应用。本文将从架构设计的角度，探讨如何利用DIFY工作流和低代码技术构建一个AI驱动的PPT生成系统。\n\n\n2. 大模型：技术背景与应用场景#\n\n大模型（如GPT、GLM等）以其强大的自然语言处理能力，正在改变我们与机器交互的方式。它们能够理解人类的自然语言指令，并生成高质量的文本内容。在前端开发中，大模\n型可以用于生成代码、优化用户体验，甚至自动化设计流程。\n\n2.1 大模型的使用方式#\n\n在实际应用中，我们发现大模型可以通过以下几种方式与前端开发结合：\n\n 1. API调用：通过调用大模型的API，前端可以直接获取生成的内容。\n 2. 嵌入式集成：将大模型嵌入到前端应用中，实现即时交互。\n 3. 数据增强：利用大模型生成的数据补充前端应用的内容。\n\n\n3. 架构设计：大模型与代码的结合#\n\n从架构的角度来看，大模型的引入不仅仅是技术的堆叠，更是对传统开发流程的重构。我们需要思考如何让人类的自然语言指令被代码理解和执行。\n\n3.1 架构设计原则#\n\n 1. 模块化：将系统拆分为前端、后端和AI工作流三个模块，每个模块负责特定的功能。\n 2. 解耦：通过API和中间件实现模块之间的通信，减少耦合度。\n 3. 可扩展性：设计时考虑未来功能的扩展，如接入更多AI工具或支持更多文件格式。\n\n\n4. 工作流设计：大模型架构中的重点#\n\n工作流是大模型架构的核心，它定义了数据的流动和处理方式。在我们的AI-PPT项目中，工作流的设计尤为重要，因为它直接决定了系统的效率和用户体验。\n\n4.1 工作流的关键环节#\n\n 1. 用户输入处理：通过前端界面接收用户输入，如主题、内容大纲等。\n 2. AI内容生成：调用DIFY工作流，利用大模型生成PPT内容和结构。\n 3. 数据清洗与格式化：对生成的内容进行清洗和格式化，确保其符合PPT的JSON结构。\n 4. 前端渲染与交互：将生成的PPT内容渲染到前端界面，支持在线编辑和导出。\n\n\n5. 技术选型与实现思路#\n\n在架构设计的基础上，我们选择了以下技术栈：\n\n * 前端：Vue3、Typescript，用于构建用户界面和交互逻辑。\n * 后端：Express，用于处理业务逻辑和API调用。\n * AI工作流：DIFY，用于实现多轮对话和内容生成。\n\n5.1 实现思路#\n\n 1. 输入到输出的流程：\n    \n    * 用户输入主题和大纲。\n    * 前端通过API将输入发送到DIFY。\n    * 调用DIFY工作流，生成PPT的JSON结构。\n    * 前端解析JSON并渲染PPT，支持在线编辑和导出。\n\n 2. 知识体系构建：\n    \n    * 利用大模型生成高质量的PPT内容。\n    * 通过规则引擎对生成的内容进行优化和调整。\n\n 3. 数据流设计：\n    \n    * 数据从用户输入开始，经过AI处理，最终生成PPT文件。\n    * 每个环节都有明确的输入和输出，确保数据的流动性和准确性。\n\n\n6. 架构优势与延展性#\n\n通过大模型+低代码+规则引擎的组合，我们构建了一个稳定且灵活的技术架构。这种架构不仅能够快速实现功能，还具备以下优势：\n\n 1. 高效性：大模型能够快速生成高质量的内容，减少人工干预。\n 2. 可扩展性：低代码设计允许快速迭代和功能扩展。\n 3. 灵活性：规则引擎可以根据需求调整生成的内容和格式。\n\n6.1 延展性思考#\n\n未来，我们计划进一步优化架构，例如：\n\n * 接入本地知识库：提升内容生成的准确性和专业性。\n * 支持更多文件格式：如Word、Excel等，拓展应用范围。\n * 优化性能：降低Token消耗，提升系统响应速度。\n\n\n7. 结论#\n\n本文从架构设计的角度，探讨了如何将大模型与前端开发相结合，构建一个AI驱动的PPT生成系统。通过模块化设计、工作流优化和低代码技术的应用，我们不仅实现了高效的内\n容生成，还为未来的发展提供了广阔的空间。这种架构设计思路不仅适用于PPT项目，还可以推广到其他AI驱动的前端应用中。","routePath":"/dify/ai-ppt/3.AIPPT的架构设计说明","lang":"","toc":[{"text":"**1. 引言：AI与前端的融合**","id":"1-引言ai与前端的融合","depth":3,"charIndex":-1},{"text":"**2. 大模型：技术背景与应用场景**","id":"2-大模型技术背景与应用场景","depth":3,"charIndex":-1},{"text":"**2.1 大模型的使用方式**","id":"21-大模型的使用方式","depth":4,"charIndex":-1},{"text":"**3. 架构设计：大模型与代码的结合**","id":"3-架构设计大模型与代码的结合","depth":3,"charIndex":-1},{"text":"**3.1 架构设计原则**","id":"31-架构设计原则","depth":4,"charIndex":-1},{"text":"**4. 工作流设计：大模型架构中的重点**","id":"4-工作流设计大模型架构中的重点","depth":3,"charIndex":-1},{"text":"**4.1 工作流的关键环节**","id":"41-工作流的关键环节","depth":4,"charIndex":-1},{"text":"**5. 技术选型与实现思路**","id":"5-技术选型与实现思路","depth":3,"charIndex":-1},{"text":"**5.1 实现思路**","id":"51-实现思路","depth":4,"charIndex":-1},{"text":"**6. 架构优势与延展性**","id":"6-架构优势与延展性","depth":3,"charIndex":-1},{"text":"**6.1 延展性思考**","id":"61-延展性思考","depth":4,"charIndex":-1},{"text":"**7. 结论**","id":"7-结论","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"Dify 文档中心","content":"#\n\n\n概述#\n\nDify 是一个开源的AI应用开发平台，帮助开发者快速构建和部署AI应用。","routePath":"/dify/","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"","content":"不知道大家是否有用过秘塔的工作流，可以根据大纲生成不同类型的分析报告，如下图所示。本篇文章就教大家如何用Dify开发一个工作流，去复刻这个功能。\n\n\n\n\n一、工作流拆解#\n\n这个工作流的流程非常清晰，用户选择报告类型和报告主题 -> 工作流根据类型拿到该报告的大纲 -> 迭代生成每一段的内容 ->\n调用http，输出成pdf。如果不怕token消耗的话可以进行附加的操作：检查段落连续性、检测有图表数据的地方生成图表。 大概的工作流程如下：\n\n\n\n\n二、结点讲解#\n\n\n1、chatflow or workflow#\n\n两者的区别是：chatflow有一个query，也就是用户输入的变量，主要用来进行多轮对话，workflow没有memory相关功能，偏向于自动化和批处理情景。\n\n在这个案例中，整体大的工作流用的是chatflow，可以多次对话，其中小的联网搜索功能，是封装了一个workflow，发布成自定义工具进行调用。\n\n\n2、知识库#\n\n我这里用知识库存储大纲，不同类型的大纲用固定的分隔符分割，然后在创建知识库的时候，用自己选择分隔符去创建，这样就能把知识库当做一个数据库去存储一些东西，最后的效\n果就是每一个类型的报告的大纲会被知识库分成一个分段（如下图所示）。\n\n当然也可以把大纲存储在会话变量或者让llm去直接生成，都是可以的。只是我这里会选择直接用秘塔的大纲去生成报告。\n\njs\n\n代码解读\n\n复制代码\n\n//提取知识库内存储的大纲 function main({arg1}) { const temp=arg1[0].content.split('：\\n')\nconst temp2=temp[1].split('\\n') return { result: temp2 } }\n\n\n\n\n\n\n3、报告内容迭代生成#\n\n我们要把大纲提取出来，转换成一个数据，供迭代节点使用。迭代节点需要输入一个数组，输出结果也是一个数组，可以选择并行数量，但是这样可能会影响输出顺序，特别是迭代节\n点中包含http的情况下。\n\n\n\n\n4、根据大纲和报告主题联网搜索#\n\n下面是我的提示词，用的是moonshotAPI，有联网的工具（具体的http请求怎么写可以看官网或者我之前的文章）。这个api是可以输出来源的，要用提示词进行约\n束。（但也不是很稳定，问过kimi客服，可能是一些内容合规的问题）\n\n\n\nmarkdown\n\n代码解读\n\n复制代码\n\n##角色：你是一个专业的文章创作者，尤其擅长分工合作，能够根据大纲的要求创作其中一个部分的内容，同时保证兼顾整个大纲，做到和其他部分能够融合自然，没有冲突，注意\n协调性和一致性。\n##任务：首先这是一个【报告名称】，主题是：【主题】，参考完整的大纲内容：【完整大纲】，然后针对其中的【部分标题】进行创作，完成这一标题下的内容，并保证内容的专\n业性和严谨性。 给出具体的数据来源，数据来源用[1]、[2]类似的输出，格式是markdown链接，数据来源重复的话，输出一次来源链接即可，不要给重复的链接。\n图文结合，适当输出Markdown表格，例如：在公司简介处可以输出一个公司关键里程碑的表格。 图片能获取连接的话，用Markdown链接展示。\n最后返回一个markdown的文本内容，不要使用<code>标签，注意标题层级。 ##【完整大纲】= ##【部分标题】= ##【报告名称】= ##【主题】=\n\n显示的效果：\n\n\n\n\n\n\n三、输出图表#\n\n在领导想看报告的时候，可能都有看图表的要求，表格的话非常容易，因为md支持直接输出表格格式的，在提示词里加上适当输出md表格就可以。而图的话，有很多种方式，比如\n拿到数据让大模型生成svg代码，然后用代码转base64图片输出，或者生成echarts的options，再去渲染。最重要的还是如何拿到靠谱的数据。\n\n\n\n\necharts#\n\n我们知道如果直接使用dify的聊天框，那他们的聊天框是支持直接输出echarts图表的，只要符合输出 ```echarts ``` 这样的格式。\n\njs\n\n代码解读\n\n复制代码\n\n//一个示例 ‍```echarts { \"title\": { \"text\": \"2024年1-3月签约额及同比变化\", \"textStyle\": {\n\"color\": \"#000000\", \"fontSize\": 18 }, \"top\": \"3%\", \"left\": \"center\" },\n\"backgroundColor\": \"#FFFFFF\", \"grid\": { \"top\": \"20%\", \"bottom\": \"10%\" },\n\"tooltip\": { \"trigger\": \"axis\", \"axisPointer\": { \"type\": \"shadow\" } }, \"legend\":\n{ \"data\": [\"签约额\", \"同比\"], \"top\": \"10%\", \"textStyle\": { \"color\": \"#000000\" } },\n\"toolbox\": { \"feature\": { \"saveAsImage\": { \"show\": true, \"title\": \"保存为图片\" },\n\"magicType\": { \"show\": true, \"type\": [\"bar\", \"line\", \"pie\"], \"title\": { \"bar\":\n\"柱状图\", \"line\": \"折线图\", \"pie\": \"饼图\" } } } }, \"xAxis\": { \"type\": \"category\",\n\"data\": [\"2024-01\", \"2024-02\", \"2024-03\"], \"axisLine\": { \"lineStyle\": { \"color\":\n\"#CBDDF4\" } }, \"axisLabel\": { \"color\": \"#000000\" } }, \"yAxis\": [ { \"type\":\n\"value\", \"name\": \"签约额 (元)\", \"position\": \"left\", \"axisLine\": { \"lineStyle\": {\n\"color\": \"#CBDDF4\" } }, \"axisLabel\": { \"color\": \"#000000\", \"formatter\":\n\"{value}\" } }, { \"type\": \"value\", \"name\": \"同比 (%)\", \"position\": \"right\",\n\"axisLine\": { \"lineStyle\": { \"color\": \"#CBDDF4\" } }, \"axisLabel\": { \"color\":\n\"#000000\", \"formatter\": \"{value} %\" } } ], \"series\": [ { \"name\": \"签约额\", \"type\":\n\"bar\", \"data\": [221692736, 212009193, 421231259185], \"itemStyle\": { \"color\":\n\"#ee7c4b\" }, \"label\": { \"show\": true, \"position\": \"top\", \"formatter\": \"{c}\" } },\n{ \"name\": \"同比\", \"type\": \"line\", \"yAxisIndex\": 1, \"data\": [21.5, 12.1, 7.87],\n\"itemStyle\": { \"color\": \"#80BD95\" }, \"label\": { \"show\": true, \"position\": \"top\",\n\"formatter\": \"{c}%\" } } ] } ‍```\n\n\nsvg#\n\n生成svg代码的提示词↓\n\njs\n\n代码解读\n\n复制代码\n\n你是一个SVG图表生成大师，可以生成美观的SVG图表，字体不重叠，间距合理。仅输出svg代码。 任务： Step 1：检查用户输入内容\n检查用户输入是否包含可用于生成柱状图、饼图或折线图的数据。 如果有数据，提取横坐标（X轴）和纵坐标（Y轴）的数据，或者饼图数据，继续下一步。\n如果没有数据，停止思考，输出：无。 Step 2：生成SVG图表 如果有数据，根据数据生成SVG图表，确保图表美观、间距合理。 柱状图要求：\n每个柱子的高度适配他的数据值，确保柱子从Y轴底部（最小值）开始绘制。 柱子之间应有合理的间距，避免重叠。\n每个柱子的填充颜色（fill属性）应不同，且颜色对比明显。 在每个柱子的顶部或旁边添加文本标签，显示具体数据值，确保文本不会超出图形边界或与其他元素重叠。\n折线图要求： 折线应根据数据点动态绘制，确保线条平滑。 在每个数据点旁边添加文本标签，显示具体数据值。 饼图要求： 每个扇区的角度应根据数据值动态计算。\n在每个扇区旁边添加文本标签，显示具体数据值和百分比。 控制SVG的大小，确保图表不会过大（例如，宽度不超过600px，高度不超过400px）。 Step\n3：检查SVG代码 检查生成的SVG代码，确保： 文本的y坐标不会超出图形边界。 所有元素（如柱子、线条、文本）的位置和大小正确。\n仅输出纯粹的SVG代码，不要输出其他文字。确保代码可以直接渲染。 关键点： 文本标签位置：确保文本标签位于柱子顶部或旁边，且不会超出边界；\n颜色和间距：确保柱子颜色对比明显，且柱子之间有合理间距。 仅输出svg代码：不需要多余的解释和文本，只返回纯净的svg代码，不要给我Markdown的格式。\n\n拿到输出之后先去掉开头结尾的 ```svg ``` 然后用代码节点转换成base64的链接地址\n\npython\n\n代码解读\n\n复制代码\n\nimport base64 def main(svg_string: str) -> dict: # 检查输入是否无效 if '无' in svg_string\nor not svg_string.strip(): return {\"result\": \"\"} # 将SVG编码为Base64格式 encoded_svg =\nbase64.b64encode(svg_string.encode('utf-8')).decode('utf-8') # 构建data URI\ndata_uri = f\"data:image/svg+xml;base64,{encoded_svg}\" return { \"result\":\ndata_uri, }\n\n拿到这个可访问的地址url 就可以用!(图片名称)[url]这样的md格式，直接显示出来。\n\n总之，显示的方法有很多关键是数据的提取。然后提示词也需要调整，不然生成的svg代码会有很多很多问题，太自由了。\n\n一个生成示例，可以看出来svg还是有点问题的。\n\n\n四、细节的优化#\n\n最后的报告转成pdf形式\n\njs\n\n代码解读\n\n复制代码\n\n//一个node接口 接受md字符串 输出ppt 调用接口上传文件传给oss 获取pdf文件的网络路径 const { mdToPdf } =\nrequire('md-to-pdf') const axios = require('axios') const FormData =\nrequire('form-data') //不兼容 const convertToPdf = async (markdownString) => { try\n{ const pdf = await mdToPdf( { content: markdownString }, { dest: null } ) if\n(pdf) { const { content } = pdf if (content) { // 将 Uint8Array 转换为 Buffer const\nbuffer = Buffer.from(content) const formData = new FormData()\nformData.append('file', buffer, { filename: '分析报告.pdf', contentType:\n'application/pdf' }) debugger const res = await\naxios.post('http://10.86.18.55:5000/files-anon', formData, { headers: {\n...formData.getHeaders() } }) return res.data.datas.url } } } catch (error) {\nconsole.error('转换过程中发生错误：', error) return } } module.exports = { convertToPdf }\n\n添加一点对话开场白，给用户一点提示\n\n添加标注，标记正确答案，使回复更加迅速\n\n\n\n\n五、结尾#\n\n这个工作流还有很多需要优化的地方，生成图表的方式也有点不太稳定，欢迎大家一起交流，共同学习dify工作流的各种应用。","routePath":"/dify/生成多种类型的分析报告（类似秘塔）","lang":"","toc":[{"text":"一、工作流拆解","id":"一工作流拆解","depth":2,"charIndex":76},{"text":"二、结点讲解","id":"二结点讲解","depth":2,"charIndex":225},{"text":"1、chatflow or workflow","id":"1chatflow-or-workflow","depth":3,"charIndex":235},{"text":"2、知识库","id":"2知识库","depth":3,"charIndex":417},{"text":"3、报告内容迭代生成","id":"3报告内容迭代生成","depth":3,"charIndex":757},{"text":"4、根据大纲和报告主题联网搜索","id":"4根据大纲和报告主题联网搜索","depth":3,"charIndex":869},{"text":"三、输出图表","id":"三输出图表","depth":2,"charIndex":1443},{"text":"echarts","id":"echarts","depth":3,"charIndex":1612},{"text":"svg","id":"svg","depth":3,"charIndex":3207},{"text":"四、细节的优化","id":"四细节的优化","depth":2,"charIndex":4475},{"text":"五、结尾","id":"五结尾","depth":2,"charIndex":5347}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"Markdown & MDX","content":"#\n\nRspress supports not only Markdown but also MDX, a powerful way to develop\ncontent.\n\n\nMarkdown#\n\nMDX is a superset of Markdown, which means you can write Markdown files as\nusual. For example:\n\n\n\n\nUse component#\n\nWhen you want to use React components in Markdown files, you should name your\nfiles with .mdx extension. For example:\n\n\n\n\nFront matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode block#\n\n\nBasic usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow line numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/guide/","lang":"","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":88},{"text":"Use component","id":"use-component","depth":2,"charIndex":198},{"text":"Front matter","id":"front-matter","depth":2,"charIndex":336},{"text":"Custom container","id":"custom-container","depth":2,"charIndex":767},{"text":"Code block","id":"code-block","depth":2,"charIndex":1190},{"text":"Basic usage","id":"basic-usage","depth":3,"charIndex":1204},{"text":"Show line numbers","id":"show-line-numbers","depth":3,"charIndex":1332},{"text":"Wrap code","id":"wrap-code","depth":3,"charIndex":1455},{"text":"Line highlighting","id":"line-highlighting","depth":3,"charIndex":1580},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1712}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! 🎁","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"","content":"","routePath":"/","lang":"","toc":[],"domain":"","frontmatter":{"pageType":"custom","hero":{"name":"akira-blog","text":"A cool website!","tagline":"This is the tagline","actions":[{"theme":"brand","text":"Quick Start","link":"/guide/"},{"theme":"alt","text":"GitHub","link":"https://github.com/web-infra-dev/rspress"}],"image":{"src":"/rspress-icon.png","alt":"Logo"}},"features":[{"title":"Blazing fast build speed","details":"The core compilation module is based on the Rust front-end toolchain, providing a more ultimate development experience.","icon":"🏃🏻‍♀️"},{"title":"Support for MDX content writing","details":"MDX is a powerful way to write content, allowing you to use React components in Markdown.","icon":"📦"},{"title":"Built-in full-text search","details":"Automatically generates a full-text search index for you during construction, providing out-of-the-box full-text search capabilities.","icon":"🎨"},{"title":"Simpler I18n solution","details":"With the built-in I18n solution, you can easily provide multi-language support for documents or components.","icon":"🌍"},{"title":"Static site generation","details":"In production, it automatically builds into static HTML files, which can be easily deployed anywhere.","icon":"🌈"},{"title":"Providing multiple custom capabilities","details":"Through its extension mechanism, you can easily extend theme UI and build process.","icon":"🔥"}]},"version":""},{"id":20,"title":"作品展示","content":"#","routePath":"/large-screen/","lang":"","toc":[],"domain":"","frontmatter":{"sidebar":true,"globalUIComponents":false},"version":""},{"id":21,"title":"数字大屏适配的解决方案","content":"#\n\n随着数字化转型的加速，越来越多的企业使用大屏显示数据，适配不同分辨率和设备变得至关重要。大屏的适配方案有很多，vw、vh；rem；viewpoint；trans\nform等等，通常需要多种方案结合使用。本文介绍一下我的解决方案是如何构建出一个响应式、可维护的数字大屏架构的。\n\n * datav的全屏容器组件dv-full-screen-container 完成初步响应式页面\n * PostCSS 插件：postcss-px-to-rem将px转换成rem\n * 监听屏幕resize，计算屏幕缩放比，echarts字体大小单独动态处理\n * 灵活的布局策略，使用百分比和flex布局\n\n这样的方案结合就能确保大屏在各个分辨率下都能够得到很好的展示。\n\n\ndatav的全屏容器组件#\n\n看了dv-full-screen-container的源码，他的实现其实也不复杂，核心就是用transform: scale()\n来缩放容器。这使得内容能够根据屏幕宽度进行适当缩放，适应不同的屏幕，以保持视觉上的一致性。使用了 position:\nfixed，将容器固定在视口的左上角。再结合flex和百分比布局，初步的响应式设计就完成了，这样后续搭建内部的框架就很容易了。\n\n\nPostCSS 插件：postcss-px-to-rem#\n\n使用插件将所有的px转换成rem单位，可以更灵活地控制字体和元素的大小、边距，也能更好地与根字体大小结合，提升适配性。\n（使用px主要还是因为px用的多，比较熟练，写样式、控制大小比较方便，如果用vh、vw也是可以的。\n\n * 值得注意的是：postcss-px-to-rem对内联样式无效，因为postcss-px-to-rem主要是针对外部样式表和css文件，将css中的px单\n   位识别出来，按照规则转换成rem单位，而内联样式嵌入在HTML元素中，插件是无法识别的。所以要尽量避免内联，确保所有样式都能通过 PostCSS 处理。\n\n\n\n新建rem.js文件并在main.js中引入\n\n\n\n\necharts字体大小动态设置#\n\nechart的单位默认是px的（好像也不支持vh、vw），1920×1080的设计稿如果需要适配4K屏幕的话，图像的x轴y轴字体会非常小，所以echart字体大\n小的适配我是单独去做的。\n\n适配的方式很简单，就是获取缩放比scale之后，然后修改原来的字体大小，比如4K屏幕（3840×2160）相较于1920×1080，scale就是2，原来字体1\n4px的地方修改为28px。\n\n\n\n\n\ngetFontSize是一个很简单的公用方法\n\n\n\n\n开机自启动#\n\n如果需要展示在电视机上，老板不想要浏览器打开，或者做了看板但是不适配安卓系统，或者需要将大屏项目设置为开机自启动的应用，可以选择把项目用hbuilder打包成a\npk文件，这样很多问题都能迎刃而解。 （也可以写个脚本，每次开机就启动浏览器，打开大屏。\n\n\n\n尽管大屏适配的过程可能比较繁琐，但通过合理的方案组合和架构设计，我们不仅能确保信息在不同设备上的可读性和一致性，还能提升用户体验。希望本文能为各位的大屏适配工作\n提供一些实用的思路和参考。欢迎讨论。","routePath":"/large-screen/数字大屏适配的解决方案","lang":"","toc":[{"text":"datav的全屏容器组件","id":"datav的全屏容器组件","depth":2,"charIndex":331},{"text":"PostCSS 插件：postcss-px-to-rem","id":"postcss-插件postcss-px-to-rem","depth":2,"charIndex":536},{"text":"echarts字体大小动态设置","id":"echarts字体大小动态设置","depth":2,"charIndex":869},{"text":"开机自启动","id":"开机自启动","depth":2,"charIndex":1110}],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"iframe的加载时展示loading动画&动态加载路由（伪）","content":"#\n\n最近有一个需求需要在页面内嵌一个iframe，用来加载其他网站，第一次使用iframe，研究了一下。\n在网上看到了形形色色的判断iframe是否加载的方式，用了最简单的一种，直接加一个onload函数判断，onload\n事件在frame或者iframe载入完成后被触发。\n\nps：感觉iframe的坑好多，有很多的网站是不支持被iframe内嵌的，比如百度、知乎等…1. 添加一个X-Frame-Options响应头就行了\n\n\n\n效果\n\n如图 需求还有一点是外链的地址需要动态加载出来的，但是我们路由是静态的配置路由（umi）。看了文档之后发现可以在layout那边用\nmenuDataRender来动态修改路由，但是如果要异步加载的话需要用到menu.request\n\n\n\n最后发现components是动态挂载不上去的，所以只能增加了path之后，把所有的path都映射到已有的页面组件。\n\n\n\n\n\n还在研究若依的动态路由、约定式路由，有些地方实在看不懂orz。。。","routePath":"/project-plan/iframe的加载时展示loading动画&动态加载路由（伪）","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"","content":"","routePath":"/project-plan/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"三、调用摄像头浏览器的限制","content":"好久没写笔记了，最近有点懒，今天需求都写完了，写一篇笔记记录一下昨天写的代码。\n\n需求是这样的：使用的是vue2，需要一个能够调用摄像头之后识别二维码和条形码的组件，获取到条码数据之后传给父组件，父组件其实是一个弹窗里面加一个form，for\nm表单填写好，条码数据也收集到之后就可以提交了。我找了好几个识别库，发现挺多都不能识别条形码的。\n\n测试的时候了解了这几个库：\n\n\n一、了解几个识别库#\n\n * 1、@zxing/library\n\nZXing能识别条形码和二维码，识别率挺高，官网给的示例清晰，支持从图片或者从摄像头中读取，我实际使用的也是这个库，推荐的。\nzxing-js.github.io/library/ 这个是示例，非常有用，示例代码拿来改成vue2能用的版本就行了。\n\n\n\n * 2、qrcode-reader\n\n这个库用起来比较简单，但是只能识别二维码，也有自带的api可以调用摄像头。\n\n * 3、Quagga\n\n这个库只能识别条形码，不能扫描二维码，chatGPT还跟我说都能扫…害我写了半天。(这个好像没人维护了\n\n还有一些其他的没咋用过。\n\n\n二、封装识别条码组件#\n\n子组件：\n\n（第一次用这个码上掘金，如果打不开可以直接建个新的vue文件复制过去，用的是vue2.其实就是官网的例子，然后用gpt改成vue2版本，但是确实改了很久emmm\n）\n\n父组件中调用：\n\n\n\n大致就长这样，手机可以通过下面的select切换前置后置，优先选后置（根据设备名进行选择，看设备名是否包括back，否则就默认选第一个）\n\n\n\n\n三、调用摄像头浏览器的限制#\n\n调用摄像头浏览器是有安全限制的，本地开发可以用localhost调试（默认安全的），上线的话就必须是https环境了。\n\n\n\n但是看到一个博客可以解决上线也只能用https的问题。当然这个解决方法只是临时性的，如果真的用不了https，可以看看这个方法。blog.csdn.net/qq\n_40905132…","routePath":"/project-plan/zxing识别二维码和条形码","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"前端文件的预览和打印/HTML打印/HTML转pdf","content":"#\n\n总结了一下前端预览和打印的几个场景\n\n\n1、PDF文件流直接预览打印#\n\n不直接下载文件，而是调用浏览器的打印功能。这里用的是iframe实现的，iframe的src可以直接接收blob转url之后的数据，进行在线的预览。\n\njs\n\n\n\nhtml\niframe展示pdf文件流如果出现乱码的问题，一定是编码有问题，可以加上meta设置编码格式（但是这样后台其实会有个错，说head不能嵌入在iframe中?）\n\n\n\n结果：调出浏览器打印页面。chrome浏览器的打印不能调整页面方向（edge可以）这是默认css样式的问题，网上也有解决方案。\n\n如果需要预览可以把iframe的display放开，或者使用object进行预览\n\n\n\n\n\n\n2、html直接打印#\n\n用了一个插件react-to-print，可以去官网看一下用法\n\n\n\n\n\n\n3、html转pdf下载#\n\n我需要指定一个html元素进行下载，网上这种案例也挺多，很多样式也可以自己调。\n\n","routePath":"/project-plan/前端文件的预览和打印-HTML打印-HTML转pdf","lang":"","toc":[{"text":"1、PDF文件流直接预览打印","id":"1pdf文件流直接预览打印","depth":2,"charIndex":22},{"text":"2、html直接打印","id":"2html直接打印","depth":2,"charIndex":322},{"text":"3、html转pdf下载","id":"3html转pdf下载","depth":2,"charIndex":373}],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"前端调用gpt制作简单gpt页面","content":"#\n\n写一个简单的聊天页面，使用SSE调用ChatGPT的接口，使用react-markdown显示获取到的数据。\n\n又来水一篇文章。后端小伙伴对于ai一直很感兴趣，想在公司的综合平台里用gpt集成知识库，让同事都可以免费使用gpt4。研究了一下，了解了一点SSE的知识点。（只\n是想法，自己写着玩儿，上线的话还需要考虑很多东西）\n\nChatGPT的打字机效果是使用SSE（Server-Sent\nEvents）获取流式数据实现的。SSE与websocket是单向的，服务器可以主动向浏览器发送数据，但是浏览器不能向服务器发。SSE基于HTTP，而webso\ncket是有另外的协议的，所以SSE的兼容性更好一点。\n\n原生的EventSource直接发送get请求，我们想发post请求可以用封装过的@microsoft/fetch-event-source\n\nreact-markdown是一个基于react的markdown解析器组件，可以在组件中直接渲染markdown格式的内容，然后通过其他插件可以给这个元素加各\n种样式。\n\njs\n\n代码解读\n\n复制代码\n\n// 划线、表、任务列表和直接url等的语法扩展 // 解析标签，支持html语法 // 代码高亮 //高亮的主题，还有很多别的主题，可以自行选择 import\n'github-markdown-css'; const AIChat: React.FC = () => { const [inputValue,\nsetInputValue] = useState<string>(''); const [loading, setLoading] =\nuseState<boolean>(false); //控制是否能input const stopReading =\nuseRef<boolean>(false); const [chatData, setChatData] = useState<Record<string,\nany>[]>([ { id: -1, content: '你好，请输入你的问题。' }, ]); const { initialState } =\nuseModel('@@initialState'); const { currentUser } = initialState || {}; const\ncount = useRef<number>(0); const [tempContent, setTempContent] =\nuseState<string>(''); const tempContent2 = useRef<string>(''); useEffect(() => {\nif (localStorage.getItem('chatData')) {\nsetChatData(JSON.parse(localStorage.getItem('chatData') || '')); } }, []); const\nctrl = new AbortController(); const fetchEventGPT = () => { setChatData([\n...chatData, { id: uuidv4(), content: inputValue, roles: 'user' }, { id:\nuuidv4(), content: '', roles: 'gpt' }, ]); count.current += 2;\nsetInputValue(''); setTempContent(''); tempContent2.current = '';\nsetLoading(true); // const data = { // channelId: '1220648311464267808', //\nmessages: [ // { // content: inputValue, // role: 'user', // }, // ], // model:\n'GPT-3.5', // stream: true, // }; const data = { content: inputValue, };\n//换成gpt的接口 fetchEventSource('http://192.168.200.207:8123/gpt/chat', { method:\n'POST', headers: { 'Content-Type': 'application/json', }, body:\nJSON.stringify(data), signal: ctrl.signal, async onopen(response) { if\n(response.ok && response.status === 200) { console.log('open'); } },\nonmessage(msg) { if (stopReading.current) { console.log('stop'); return; } if\n(msg.data === '{\"event\":\"done\"}') { console.log('done'); let temp:\nRecord<string, any>[] = []; setChatData((pre) => { pre[pre.length - 1].content =\ntempContent2.current; temp = pre; return temp; });\nlocalStorage.setItem('chatData', JSON.stringify(temp)); return; } if (msg.data)\n{ try { const datas = JSON.parse(msg.data); const { message } = datas; if\n(message?.type === 'answer' && message?.content) { tempContent2.current =\ntempContent2.current + message?.content; setTempContent(tempContent2.current); }\n// if (datas.event === 'error') { // setTempContent('出错了，' +\ndatas?.error_information?.err_msg || '请联系管理员。'); // } } catch (error) {\nconsole.log(error); } } }, onclose() { console.log('close'); stopReading.current\n= false; setLoading(false); ctrl.abort(); }, onerror(err) { console.log('error',\nerr); stopReading.current = false; setLoading(false); ctrl.abort(); //\nsource?.close(); }, }); }; const suffix = ( <SearchOutlined style={{ fontSize:\n16, }} onClick={fetchEventGPT} /> ); return ( <> <PageContainer title={false}\nstyle={{ height: '100%' }}> <ProCard style={{ marginBottom: 20, borderRadius: 5\n}}> <div className={styles.gptContent}> {chatData && chatData.length > 0 && ( <>\n{chatData.map((item) => { return ( <Row key={item.id} gutter={[24, 24]} style={{\nmarginBottom: 18 }}> {item.roles === 'user' ? ( <> <Col> <img src={\ncurrentUser?.headImgUrl ||\n'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png' }\nalt=\"\" className={styles.imgStyle} /> </Col> <Col span={20} style={{ border:\n'1px solid #cfd3d3', borderRadius: '10px', width: '100%', minHeight: '30px',\nbackgroundColor: 'rgb(93,92,222)', color: '#fff', display: 'flex',\njustifyContent: 'flex-start', alignItems: 'center', fontSize: 16, }} > <div\nid={item.id} style={{ padding: '5 2' }}> {item.content} </div> </Col> </> ) : (\n<> <Col> <img src={\n'https://psc2.cf2.poecdn.net/assets/_next/static/media/assistant.b077c338.svg' }\nalt=\"\" className={styles.imgStyle} /> </Col> <Col span={20} style={{ border:\n'1px solid #cfd3d3', borderRadius: '10px', width: '100%', minHeight: '30px', }}\n> <ReactMarkdown className=\"markdown-body\" remarkPlugins={[remarkGfm]}\nrehypePlugins={[rehypeRaw]} components={{ img(props) { return <img {...props}\nstyle={{ maxWidth: '100%' }} />; }, code({ className, children, ...props }) {\nconst match = /language-(\\w+)/.exec(className || ''); return match ? (\n<SyntaxHighlighter style={tomorrow} language={match[1]} PreTag=\"div\" {...props}\n> {String(children).replace(/\\n$/, '')} </SyntaxHighlighter> ) : ( <code\nclassName={className} {...props}> {children} ); }, }} > {item.content ?\nitem.content : tempContent} {/* {item.content ? item.content : tempContent} */}\n</> )} ); })} </> )} { stopReading.current = true; ctrl.abort(); }} > Stop {\nsetInputValue(e.target.value); }} onPressEnter={fetchEventGPT}\ndisabled={loading} /> </> ); }; export default AIChat;\n\n做了上下文的缓存，样式还有没写好的地方，没有做到poe那样，有空再继续完善。\n\n\n\n\n\n两种markdown的样式","routePath":"/project-plan/前端调用gpt制作简单gpt页面","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"文件上传","content":"文件的上传与导出#\n\n最近的项目涉及到的文件导入与导出比较多，整理一下，之前也写过vue文件的上传，那篇更详细一点。\n\n\n文件导出#\n\n导出的时候，后端基本上会给一个数据流， 请求里必须需要加上responseType:\n'blob'用来接收数据流。然后可以选择使用file-saver插件直接下载导出，很方便\n\n\n\n也可以使用老办法下载\n\n\n\n关于下载的文件名的获取，可以自己命名，也可以从请求头Content-Disposition中取，这个要和后端配合好。如果自己命名的话，记得加上文件的后缀名定义文\n件类型。\n\n这样文件的下载就完成了，浏览器会直接跳转下载。\n\n如果 通过文件的url下载，用<a>标签或者用window.open直接打开\n\n\n文件上传#\n\n文件的上传我们基本都用upload组件，element和antd的上传组件都是类似的。\n\n后端在这里可能会要求直接上传文件数据流，也有可能要求我们自己上传到服务器，获取到文件url之后再传给后端，这个在之前的文章中也写过。这次因为文件需要后端校验之后\n才能上传服务器，所以是传给后端二进制数据流的。\n\n在上传时获取file调用上传接口，file是一个二进制文件流，用append添加到FormData对象中。FormData对象可以处理各种类型的数据，包括文本、\n文件、二进制数据等。使用他我们可以将不同类型的数据添加到表单中，并一起传输发送到服务器。\n\n\n\n创建之后就可以传输formdata对象了，也可以根据接口需要去加新的参数。","routePath":"/project-plan/文件的上传与导出","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"用flex布局写骰子","content":"#\n\n\n\n（用:html5在vscode可以快速生成h5代码片段）","routePath":"/project-plan/用flex布局写骰子","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"表单的实时保存（断网、离开页面前保存等情况）","content":"#\n\n最近在写复杂表单的实时保存，一般来说可以使用onblur，但是这可能会存在最后一个没保存上，以及如果需求是想做到语雀那样的实时保存的情况就不行了。这种情况下我们\n用了onchange写缓存加定时器调用接口保存。就是有几个极限的情况需要考虑，比如快速填写之后刷新、离开页面、断网、快速提交等。\n\n1、定义一个map缓存（也可以直接用localStorage），在onchange的时候去写缓存。\n\n\n\n2、useEffect中写一个定时器轮询读取缓存，useEffect的return里可以写一些逻辑，在离开页面之前也做一些保存操作，防止定时器还没到时间去保存的\n情况。在保存成功之后，需要对比缓存中是否还有该条数据，以及是否做了新的更新，如果对象完全相同，删除缓存。\n\n\n\n3、在进入页面之前检查localStorage里有没有还没保存上的缓存数据。还有提交之前也要检查缓存是否已经清空，在清空缓存之后再去显示页面/提交数据。\n\n\n\n判断两个对象是否完全相同封装了一个函数：\n\n\n\n像语雀那样的缓存是如何做到的呢？是直接读写localStorage吗？直接多次频繁读写localStorage是否会有性能问题？还有挺多需要考虑的问题。","routePath":"/project-plan/表单的实时保存（断网、离开页面前保存等情况）","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"记录vue2图片上传的过程","content":"#\n\n之前写react的项目时，上传图片是这样的：用户点击上传选择图片之后调用接口，将图片上传至服务器，接口返回一个图片的url，之后确认保存之后会把图片的url传给\n后端进行保存。\n\n（这样的坏处好像就是如果图片取消上传了但是图片还是在服务器上。好处是可以避免存储大量图片，避免数据库变大变得缓慢，而且还可以提高数据的读写速度。）\n\n现在维护一个vue2的项目，里面上传图片的接口是直接传二进制文件给后端的，js的几个类型搞得我有点晕，整理了一下记录下来。\n\n * blob：Binary Large\n   Object的缩写，代表二进制类型的对象。Blob对象表示一个不可变、原始数据的类文件对象，其实就是类似文件对象的二进制数据。\n\n * File类型：继承自blob对象，是 JavaScript 中用来表示文件数据的一种对象类型，它通常用于在前端页面中操作文件，例如上传文件、读取文件等。\n\n * base64：二进制数据（如文件）表示为文本字符串的方法，使用一组特定的字符。网络中存储和传输的二进制数据的普遍用法。\n\n\n一、使用element的上传文件的组件。#\n\n\n\nbeforeAvatarUpload 传入的参数是file类型\n\n如果将传入的file直接赋值给对应接收的参数，是显示不出来的。\n\n> 这里是因为我没有用upload的file-list，而是通过img的scr去给这个组件赋值的。\n> <img> 标签的 src 属性必须是一个可以直接加载的图片地址，而 File 对象并不是一个图片地址，它只是一个指向本地文件的引用。\n\n> 也就是说如果用的是img的src，那必须是一个可以直接加载的图片地址（url、base64都可以），如果用的是ele的upload的file-list，Bl\n> ob 或 File 对象可以，但是base64不可以。\n\n\n\n\n二、这时候需要将类型转换成base64类型#\n\n下面代码使用了JavaScript内置的 FileReader 对象，将文件内容读取为 Data URL 格式的字符串，从而实现了将 File 类型的文件转换成\nbase64 编码字符串的功能。\n\n\n\n这样图片就可以正确显示了。\n\n\n\nbase64类型非常长，只截了部分。转换成base64类型，通常会增加文件的大小，因为它使用了一定程度的数据冗余来保证数据能够正确地转换和传输。base64\n编码会将每3个字节的二进制数据编码成4个字符，编码后的数据量会比原始数据量增加约33%。\n\n\n三、接下来需要把base64转换成二进制文件，因为后端需要的是二进制文件，其实也就是需要一个blob对象。#\n\n调用 this.dataURItoBlob() 函数，将 this.form.avatar 中的 base64 编码的图片数据转换成二进制格式的 Blob\n对象。\n\n\n\n\n四、最后传给后端的是这样的#\n\n\n\n代码是到处cv的，修改出了能用不报错的，也不知道我的理解有没有问题，有错误请各位大佬指正。","routePath":"/project-plan/记录vue2图片上传的过程","lang":"","toc":[{"text":"一、使用element的上传文件的组件。","id":"一使用element的上传文件的组件","depth":2,"charIndex":465},{"text":"二、这时候需要将类型转换成base64类型","id":"二这时候需要将类型转换成base64类型","depth":2,"charIndex":792},{"text":"三、接下来需要把base64转换成二进制文件，因为后端需要的是二进制文件，其实也就是需要一个blob对象。","id":"三接下来需要把base64转换成二进制文件因为后端需要的是二进制文件其实也就是需要一个blob对象","depth":2,"charIndex":1060},{"text":"四、最后传给后端的是这样的","id":"四最后传给后端的是这样的","depth":2,"charIndex":1202}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"需求：能不能直接粘贴图片到文本框中","content":"#\n\n某天上班，同事问我能不能把文本框改成可以粘贴图片到里面的。\n\n\n\n思考了一下，这不就是需要一个富文本框吗，开始改造。\n\n使用了富文本WangEditor（www.wangeditor.com/ ）一个配置简单开箱即用的富文本插件。\n\n\n\n函数组件内\n\n\n\nreturn中的组件内容\n\n\n\n我们获取到的富文本内容是一串字符串，内容是html，输入这样的内容\n\n\n\n111111122222233333\n\nwww\n\n得到的字符串是\n\n\n\n\n\n所以拿到字符串可以用dangerouslySetInnerHTML展示出来。不过展示原图可能太大，可以加一个maxWidth为100%的样式，然后点击图片预览，\n可以给顶层div加一个onclick监听事件，判断点击的node是不是img类型，如果是的话，就打开图片预览。\n\n\n\n\n\n拿到富文本里的图片的src，引入antd的Image预览图片\n\n\n\n\n\n总之，使用富文本，富文本内上传图片，预览富文本中的Img图片，只要合理使用WangEditor组件库和Image都能简单的完成。后续应该会把组件再封装一层，复用\n起来更方便。","routePath":"/project-plan/需求：能不能直接粘贴图片到文本框中","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]