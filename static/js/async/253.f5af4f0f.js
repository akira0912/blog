"use strict";(self.webpackChunkakira_blog=self.webpackChunkakira_blog||[]).push([["253"],{6025:function(e,n,a){a.r(n),a.d(n,{default:()=>l});var c=a(2676),r=a(453);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"表单的实时保存断网离开页面前保存等情况",children:["表单的实时保存（断网、离开页面前保存等情况）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#表单的实时保存断网离开页面前保存等情况",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"最近在写复杂表单的实时保存，一般来说可以使用onblur，但是这可能会存在最后一个没保存上，以及如果需求是想做到语雀那样的实时保存的情况就不行了。这种情况下我们用了onchange写缓存加定时器调用接口保存。就是有几个极限的情况需要考虑，比如快速填写之后刷新、离开页面、断网、快速提交等。"}),"\n",(0,c.jsx)(n.p,{children:"1、定义一个map缓存（也可以直接用localStorage），在onchange的时候去写缓存。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"onValuesChange: async (record) => {\n  const tempId = `${record.cacheId}-${record.id}`;\n  const collectValue = [];\n  for (let i = 0; i < timeArr.length; i++) {\n    collectValue.push(record[timeArr[i]] ?? '');\n  }\n  cacheMap.current.set(tempId, {\n    ...record,\n    collectValue: JSON.stringify(collectValue),\n  });\n};\n"})}),"\n",(0,c.jsx)(n.p,{children:"2、useEffect中写一个定时器轮询读取缓存，useEffect的return里可以写一些逻辑，在离开页面之前也做一些保存操作，防止定时器还没到时间去保存的情况。在保存成功之后，需要对比缓存中是否还有该条数据，以及是否做了新的更新，如果对象完全相同，删除缓存。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"  const handleBeforeUnload = async () => {\n    if (cacheMap.current.size != 0) {\n      //没保存上的缓存到localstorage中\n      localStorage.setItem(\n        `cacheMap${basicInfo?.id}`,\n        JSON.stringify(Array.from(cacheMap.current.entries())),\n      );\n    }\n  };\n\n    const onSave = async (record: CollectIQCListType) => {\n    const res = await submitCollectRowData({ ...record });\n    if (res.resp_code === 0) {\n      const key = `${record.cacheId}-${record.id}`;\n      const flag = cacheMap.current.has(key);\n      if (flag && isObjectEqual(record, cacheMap.current.get(key))) {\n        cacheMap.current.delete(key);\n      }\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    const intervalId = setInterval(() => {\n      if (cacheMap.current.size > 0) {\n        cacheMap.current.forEach((value) => {\n          if (value) {\n            onSave(value); //调用保存的接口\n          }\n        });\n      }\n    }, 1000);\n    //卸载\n    return () => {\n      clearInterval(intervalId);\n      handleBeforeUnload();\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    };\n  }, [timeArr]);\n\n"})}),"\n",(0,c.jsx)(n.p,{children:"3、在进入页面之前检查localStorage里有没有还没保存上的缓存数据。还有提交之前也要检查缓存是否已经清空，在清空缓存之后再去显示页面/提交数据。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const localKey = `cacheMap${basicInfo?.id}`;\nconst cacheStorage = localStorage.getItem(localKey);\nif (cacheStorage && cacheStorage != '[]') {\n  //因为填写的数据里会有转义字符 \\t \\n等等 用JSON.parse转会直接报错，用eval又有XSS风险…不知道如何取舍。\n  const data = eval(cacheStorage?.replaceAll(/\\n/g, '\\\\n'));\n  const newMap = new Map(data);\n  newMap.forEach((value) => {\n    if (value) {\n      onSave(value);\n    }\n  });\n  localStorage.removeItem(localKey);\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"判断两个对象是否完全相同封装了一个函数："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export const isObjectEqual = (obj1: Record<string, any>, obj2: Record<string, any>) => {\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n  for (const key of keys1) {\n    if (!obj2.hasOwnProperty(key) || obj1[key] !== obj2[key]) {\n      return false;\n    }\n  }\n  return true;\n};\n"})}),"\n",(0,c.jsx)(n.p,{children:"像语雀那样的缓存是如何做到的呢？是直接读写localStorage吗？直接多次频繁读写localStorage是否会有性能问题？还有挺多需要考虑的问题。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(t,{...e})}):t(e)}let l=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["project-plan%2F%E8%A1%A8%E5%8D%95%E7%9A%84%E5%AE%9E%E6%97%B6%E4%BF%9D%E5%AD%98%EF%BC%88%E6%96%AD%E7%BD%91%E3%80%81%E7%A6%BB%E5%BC%80%E9%A1%B5%E9%9D%A2%E5%89%8D%E4%BF%9D%E5%AD%98%E7%AD%89%E6%83%85%E5%86%B5%EF%BC%89.md"]={toc:[],title:"表单的实时保存（断网、离开页面前保存等情况）",headingTitle:"表单的实时保存（断网、离开页面前保存等情况）",frontmatter:{}}}}]);