"use strict";(self.webpackChunkakira_blog=self.webpackChunkakira_blog||[]).push([["660"],{7072:function(n,e,r){r.r(e),r.d(e,{default:()=>c});var t=r(2676),a=r(453);function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",pre:"pre",code:"code",img:"img"},(0,a.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"1自定义可编辑表格的单元格",children:["1.自定义可编辑表格的单元格",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1自定义可编辑表格的单元格",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"好久都没写过掘金文章了，失恋一场，颓废了很久，想来还是找点事做，写写知识点记录一下。"}),"\n",(0,t.jsx)(e.p,{children:"工作中真是频繁用到可编辑表格，最近一次的需求，让我把这个彻底搞明白了。"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"- 1、合并单元格"})," 这个合并单元格也是常出现的需求，column里面有一个onCell的api可以实现。 我这里合并的条件是id不同且值相同"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-tsx",children:"  const getRowSpan = (record: CollectIQCListType, dataIndex: string) => {\n    const value = record[dataIndex];\n    let rowSpan = 1;\n    for (let i = 0; i < dataSource.length; i++) {\n      if (dataSource[i].cacheId !== record.cacheId && dataSource[i][dataIndex] === value) {\n        rowSpan++;\n      }\n    }\n    return rowSpan;\n  };\n\n   {\n      title: '检验项目',\n      dataIndex: 'programName',\n      key: 'programName',\n      width: '8%',\n      align: 'center',\n      editable: false,\n      onCell: (record, rowIndex = 0) => ({\n        rowSpan:\n          rowIndex === 0 || record.programName !== dataSource[rowIndex - 1].programName\n            ? getRowSpan(record, 'programName')\n            : 0,\n      }),\n    },\n"})}),"\n",(0,t.jsx)(e.p,{children:"效果："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1089335a0dbe436892e337f9ebf8a3ea~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=475&h=389&s=11445&e=png&b=fefefe",alt:"image.png"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"- 2、自定义单元格"})," 有一个需求是，数值型的需要根据抽样数去生成输入框，且动态更新不良数，文字类型就显示一个textarea。这样就需要自定义单元格了"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.img,{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d12a4ca2bee84b0eac7e780cee60458e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=839&h=407&s=28215&e=png&b=fefefe",alt:"image.png"})," 只读模式"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce188593df2f4905bc7576f4956f0727~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=683&h=137&s=11005&e=png&b=fafafa",alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/074a5b6a5de041a7aeebe3a3acdd78c0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=617&h=67&s=4592&e=png&b=fcfbfb",alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:"编辑模式下"}),"\n",(0,t.jsxs)(e.p,{children:["其实文档里写的很清楚，只读模式的时候用render去设置单元格，编辑模式下用renderformitem去设置单元格。最开始我没搞懂这点才像个没头苍蝇一样乱转。 ",(0,t.jsx)(e.img,{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8f14943e0fe42bb8b5eb81e7a5ff118~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=948&h=171&s=14828&e=png&b=fefefe",alt:"image.png"})," 知道这两个api的作用后，代码就很简单了，在renderformitem的时候去调用自定义的组件，render只读下遍历，给每个采集值加上边框："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-jsx",children:" {\n      title: '记录',\n      dataIndex: 'collectValue',\n      key: 'collectValue',\n      width: '25%',\n      align: 'center',\n      renderFormItem: (a) => {\n        //@ts-ignore\n        if (a?.entity?.type == '1') {\n          //@ts-ignore\n          return <InputList count={a?.entity?.sampleCount || 0} />;\n        } else {\n          return <TextArea />;\n        }\n      },\n      render: (value, record) => {\n        //数值\n        if (record.type == '1') {\n          const arr = record?.collectValue?.toString().split(',') || [];\n          return (\n            <>\n              <Row gutter={[4, 4]}>\n                {arr.map((item: string, index: number) => {\n                  return (\n                    <>\n                      <Col span={6}>\n                        <div\n                          key={+new Date() + index}\n                          style={{ border: '1px solid rgb(217,217,217)', padding: 2 }}\n                        >\n                          {item}\n                        </div>\n                      </Col>\n                    </>\n                  );\n                })}\n              </Row>\n            </>\n          );\n        } else {\n          return !value || value == '-' ? '' : value;\n        }\n      },\n    },\n    \n    \n    //自定义的InputList\n    import { Col, Input, Row } from 'antd';\n\ntype InputListPropsType = {\n  count: number;\n  value?: string;\n  onChange?: (value: string) => void;\n};\nconst InputList: React.FC<InputListPropsType> = (props) => {\n  const { count, value = '', onChange = () => {} } = props;\n  const numArr = value?.toString().split(',') || [];\n  const showArr: (string | number)[] = [];\n  for (let i = 0; i < count; i++) {\n    if (i < numArr.length) {\n      showArr.push(numArr[i]);\n    } else {\n      showArr.push('');\n    }\n  }\n\n  const onSave = (collectValue: number | string, index: number) => {\n    const changeArr: (string | number)[] = [];\n    showArr.map((item, i) => {\n      if (i === index && collectValue != '') {\n        changeArr.push(collectValue);\n      } else if (item != '') {\n        changeArr.push(item);\n      }\n    });\n    onChange(changeArr.toString());\n  };\n  return (\n    <Row gutter={[4, 4]} style={{ width: '100%' }}>\n      {showArr.map((item, index) => {\n        return (\n          <>\n            <Col span={6} key={+new Date() + index}>\n              <Input\n                style={{ width: '100%' }}\n                defaultValue={item}\n                onBlur={(e) => {\n                  onSave(e.target.value, index);\n                }}\n              />\n            </Col>\n          </>\n        );\n      })}\n    </Row>\n  );\n};\n\nexport default InputList;\n\n"})}),"\n",(0,t.jsxs)(e.p,{children:["自定义组件的时候，value和onchange是自动包裹的，不需要手动去传入。 这里有两个问题因为时间比较紧急还没好好去解决： 1、renderFormItem传入的参数的类型定义，总是报错，看源码的定义是这样的 ",(0,t.jsx)(e.img,{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d67083b99d44d788eec9c20a678cd82~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=963&h=299&s=30741&e=png&b=001f33",alt:"image.png"})," 2、第二点就是遍历的时候key的选择，因为遍历的采集值也只是逗号分割的数字字符串而已，没有给唯一的id表示，用index又总是报错，最后采用了时间戳。"]}),"\n",(0,t.jsx)(e.p,{children:"仔细阅读文档才发现文档上那个例子已经写的非常清晰明了了，还是要多读文档。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c89b674d0b547e0b7a544927fac2a49~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=901&h=245&s=16779&e=png&b=f9f9f9",alt:"image.png"})})]})}function p(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(i,{...n})}):i(n)}let c=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["antd-design%2FeditableProTable%2F1.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%AF%E7%BC%96%E8%BE%91%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC.md"]={toc:[],title:"1.自定义可编辑表格的单元格",headingTitle:"1.自定义可编辑表格的单元格",frontmatter:{}}}}]);