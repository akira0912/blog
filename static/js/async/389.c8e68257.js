"use strict";(self.webpackChunkakira_blog=self.webpackChunkakira_blog||[]).push([["389"],{8194:function(e,n,t){t.r(n),t.d(n,{default:()=>r});var c=t(2676),i=t(453);function p(e){let n=Object.assign({p:"p",img:"img",pre:"pre",code:"code"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.p,{children:"在开发中，如果有展示公司层级、学科系统、分类目录的需求的话，就经常会需要将对象数组的结构转成树型结构，然后应用到antd组件里，比如Tree树形控件、TreeSelect树形选择器、树形数据展示的Table等。"}),"\n",(0,c.jsxs)(n.p,{children:["Tree ",(0,c.jsx)(n.img,{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4ad9e6aa21c43268e7e9e2ea76749f8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?",alt:"image.png"})]}),"\n",(0,c.jsxs)(n.p,{children:["TreeSelect ",(0,c.jsx)(n.img,{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/713b83249f2345788cb4a1c2edf947d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?",alt:"image.png"})]}),"\n",(0,c.jsxs)(n.p,{children:["Table ",(0,c.jsx)(n.img,{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3df548cf545457c9c4a5a0c66ca78b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?",alt:"image.png"})]}),"\n",(0,c.jsx)(n.p,{children:"只需要将数据转换成如下结构即可："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33470fa2f85145e4ba438141774cfbf8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?",alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"转换之前就是一普通对象数组"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fcf1e5435cd4f0dbd8b5ab2b51d5ab7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?",alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"递归遍历，时间复杂度可能略高，但是我这里数据层级不超过三四层，所以还好。转换的代码如下：（转换成table需要的树形数据）"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ini",children:"useEffect(() => {\n    const x = testMenu; //要转换的数据\n    setLoading(true);\n    const resultTemp = arrayToTree(x, -1); \n    const result = deleteChildren(resultTemp);\n    //console.log(result)\n    setData(result);\n    setLoading(false);\n    setExpandKeys(tempExpandKey.current);\n  }, []);\n  \n  const count = useRef<number>(1); \n  const tempExpandKey = useRef<React.Key[]>([]); //保存树所有的key\n  const getChildren = (data2: MenuManageType[], result: MenuManageType[], pId: number) => {\n    if (pId >= -1) {\n      for (const item of data2) {\n        if (item.parentId === pId) {\n          const newItem = {\n            id: item.id,\n            name: item.name,\n            url: item.url,\n            path: item.path,\n            css: item.css,\n            sort: item.sort,\n            type: item.type,\n            keyValue: count.current,\n            children: [],\n          };\n          result.push(newItem);\n          count.current++;\n          getChildren(data2, newItem.children, item.id);\n        }\n      }\n    }\n  };\n  const arrayToTree = (data1: MenuManageType[], pId: number) => {\n    const result: MenuManageType[] = [];\n    getChildren(data1, result, pId);\n    return result;\n  };\n  //带children渲染table，children为[]也会有+展开符 需要删掉children字段。不知道如何优化\n  const deleteChildren = (data3: MenuManageType[]) => {\n    const childTemp: MenuManageType[] = data3;\n    //console.log(childTemp)\n    for (let i = childTemp.length; i >= 0; i--) {\n      if (childTemp[i] && childTemp[i].children) {\n        if (childTemp[i].children?.length) {\n          tempExpandKey.current.push(childTemp[i].id);\n          deleteChildren(childTemp[i].children);\n        } else {\n          delete childTemp[i].children;\n        }\n      }\n    }\n    return data3;\n  };\n"})}),"\n",(0,c.jsx)(n.p,{children:"写的很烂，大佬如果有修改意见，请尽管提出。"}),"\n",(0,c.jsxs)(n.p,{children:["如果想要table的树形结构在第二列展开可以加一行，不过文档中好像没有给出 ",(0,c.jsx)(n.code,{children:"expandIconColumnIndex={1}"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e312fdf12974485b2df94fec16eb947~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?",alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"总结：对象数组扁平化转成树形结构这个算法还挺常用的，还可以继续优化一下，不用递归，时间复杂度太高，还可以提取出来做成一个通用的函数。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(p,{...e})}):p(e)}let r=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["antd-design%2Ftree%2F1.%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93.md"]={toc:[],title:"",headingTitle:"",frontmatter:{}}}}]);