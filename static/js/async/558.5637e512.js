"use strict";(self.webpackChunkakira_blog=self.webpackChunkakira_blog||[]).push([["558"],{7889:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var a=r(2676),s=r(453);function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"文件的上传与导出",children:["文件的上传与导出",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#文件的上传与导出",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"最近的项目涉及到的文件导入与导出比较多，整理一下，之前也写过vue文件的上传，那篇更详细一点。"}),"\n",(0,a.jsxs)(n.h1,{id:"文件导出",children:["文件导出",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#文件导出",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["导出的时候，后端基本上会给一个数据流， 请求里必须需要加上",(0,a.jsx)(n.code,{children:"responseType: 'blob'"}),"用来接收数据流。然后可以选择使用",(0,a.jsx)(n.code,{children:"file-saver"}),"插件直接下载导出，很方便"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { saveAs } from 'file-saver';\n//调用导出接口\nif (res) {\n   saveAs(res, '文件名');\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"也可以使用老办法下载"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"\n      const url = URL.createObjectURL(res);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      a.click();\n      URL.revokeObjectURL(url);\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:["关于下载的文件名的获取，可以自己命名，也可以从请求头",(0,a.jsx)(n.code,{children:"Content-Disposition"}),"中取，这个要和后端配合好。如果自己命名的话，记得加上文件的后缀名定义文件类型。"]}),"\n",(0,a.jsx)(n.p,{children:"这样文件的下载就完成了，浏览器会直接跳转下载。"}),"\n",(0,a.jsxs)(n.p,{children:["如果 通过文件的url下载，用",(0,a.jsx)(n.code,{children:"<a>"}),"标签或者用",(0,a.jsx)(n.code,{children:"window.open"}),"直接打开"]}),"\n",(0,a.jsxs)(n.h1,{id:"文件上传",children:["文件上传",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#文件上传",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"文件的上传我们基本都用upload组件，element和antd的上传组件都是类似的。"}),"\n",(0,a.jsx)(n.p,{children:"后端在这里可能会要求直接上传文件数据流，也有可能要求我们自己上传到服务器，获取到文件url之后再传给后端，这个在之前的文章中也写过。这次因为文件需要后端校验之后才能上传服务器，所以是传给后端二进制数据流的。"}),"\n",(0,a.jsxs)(n.p,{children:["在上传时获取file调用上传接口，",(0,a.jsx)(n.code,{children:"file"}),"是一个二进制文件流，用append添加到",(0,a.jsx)(n.code,{children:"FormData"}),"对象中。",(0,a.jsx)(n.code,{children:"FormData"}),"对象可以处理各种类型的数据，包括文本、文件、二进制数据等。使用他我们可以将不同类型的数据添加到表单中，并一起传输发送到服务器。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"\n        <Upload\n              {...props}\n              beforeUpload={(file) => {\n                handleUploadChange(file, record.bankId, index);\n              }}\n            >\n              <Button type=\"link\" style={{ color: '#3E8BF8' }} loading={btnLoading2[index]}>\n                上传\n              </Button>\n            </Upload>\n      \n      //在handleUploadChange中写\n      const formData = new FormData();\n      formData.append('file', file);\n      //调用上传接口\n"})}),"\n",(0,a.jsx)(n.p,{children:"创建之后就可以传输formdata对象了，也可以根据接口需要去加新的参数。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["project-plan%2F%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E5%AF%BC%E5%87%BA.md"]={toc:[],title:"文件上传",headingTitle:"文件上传",frontmatter:{}}}}]);