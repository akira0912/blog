"use strict";(self.webpackChunkakira_blog=self.webpackChunkakira_blog||[]).push([["864"],{3006:function(e,n,t){t.r(n),t.d(n,{default:()=>i});var a=t(2676),r=t(453);function l(e){let n=Object.assign({p:"p",code:"code",pre:"pre",img:"img"},(0,r.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"最近有一个需求是可编辑表格里需要自定义组件，比如可多选的select，遇到了很多问题，编辑的时候数据需要反显，valueEnum的类型，renderFormItem的写法等等，EditableProTable已经能满足了很多需求，但是文档有点点难看懂。"}),"\n",(0,a.jsxs)(n.p,{children:["如果是单选下拉框的话可以写",(0,a.jsx)(n.code,{children:"valueType:'select'"}),"，我想要多选的select，chatGPT居然告诉我这样写：",(0,a.jsx)(n.code,{children:"valueType:'select-multiple'"}),"……不知道他从哪儿学习到的，反正是错误的写法……"]}),"\n",(0,a.jsx)(n.p,{children:"EditableProTable的示例代码如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-css",children:"  const [dataSource, setDataSource] = useState([{ id: '1', errorType: [2, 1] }]);\n  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>([]);\n  const [isPE, setIsPE] = useState<boolean>(false); //控制是否能编辑\n  \n  const columns: ProColumns<any, any>[] = [\n    {\n      title: '序号',\n      dataIndex: 'id',\n      key: 'id',\n      width: '15%',\n      hideInTable: true,  //在列表内隐藏\n    },\n    {\n      title: '异常类型',\n      dataIndex: 'errorType',\n      key: 'errorType',\n      width: '15%',\n      valueEnum: {        \n      // 我发现如果要多选下拉正常的话，valueEnum和select的options都得写，有大佬可以解释一下吗\n        1: '管理员',\n        2: '编辑员',\n        3: '操作员',\n      },\n      formItemProps: {\n        rules: [{ required: true, message: '请输入异常类型' }],   \n      },\n      editable: isPE,     //这里可以控制isPE的值去操纵这个单元格是否可以编辑\n      align: 'center',\n      renderFormItem: () => {\n        return (\n          <Select\n            mode={'multiple'}\n            // onChange={() => onSelectChange(row)}\n            // onClick={() => showSalespersonModal(row)}\n            options={[{ label: '管理员', value: 1 },{ label: '编辑员', value: 2 },{ label: '操作员', value: 3 },            ]}\n          />\n        );\n      },\n    },\n    {\n      title: '描述',\n      dataIndex: 'remark',\n      key: 'remark',\n      width: '15%',\n      editable: isPE,\n      align: 'center',\n    },\n    {\n      title: '异常定位',\n      dataIndex: 'errorLocation',\n      key: 'errorLocation',\n      width: '15%',\n      valueType: 'select',\n      mode: 'multiple', // 设置为多选\n      formItemProps: {\n        rules: [{ required: true, message: '请输入异常定位' }],\n      },\n      valueEnum: {\n        1: { text: '类型1' },\n        2: { text: '类型2' },\n        3: { text: '类型3' },\n      },\n      editable: !isPE,\n      align: 'center',\n      renderFormItem: () => {\n        return (\n          <Select\n            mode={'multiple'}\n            options={[              { label: '类型1', value: 1 },              { label: '类型2', value: 2 },              { label: '类型3', value: 3 },            ]}\n          />\n        );\n      },\n    },\n    {\n      title: '原因描述',\n      dataIndex: 'reason',\n      key: 'reason',\n      width: '15%',\n      editable: !isPE,\n      align: 'center',\n    },\n    {\n      title: '操作',\n      valueType: 'option',\n      width: '15%',\n      align: 'center',\n      render: (text, record, _, action) => [\n        <a\n          key=\"editable\"\n          onClick={() => {\n            action?.startEditable?.(record.id);\n          }}\n        >\n          编辑\n        </a>,\n        <a\n          key=\"delete\"\n          onClick={() => {\n            setDataSource(dataSource.filter((item) => item.id !== record.id));\n          }}\n        >\n          删除\n        </a>,\n      ],\n    },\n  ];\n  \n  \n  return (<EditableProTable\n        rowKey=\"id\"\n        value={dataSource}\n        onChange={setDataSource}\n        onlyAddOneLineAlertMessage=\"请保存后再新增！\"\n        columns={columns}\n        recordCreatorProps={{\n          position: 'bottom',\n          record: () => ({\n            id: (Math.random() * 1000000).toFixed(0),  //id作为rowKey必须唯一，新增的时候先随机取一个id\n          }),\n        }}\n        editable={{\n          type: 'multiple',\n          editableKeys,\n          onSave: async (rowKey, data, row) => {\n            console.log(rowKey, data, row);\n          },\n          onChange: setEditableRowKeys,\n        }}\n      />\n    );\n  \n  \n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3b6fe9f7bba489c911ec230834e33e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?",alt:"image.png"})," 这样写EditableProTable里面就可以有多选的select了。这只是一个简单的例子 后面还要写的更复杂一点、对一点接口，可编辑表格感觉还是挺常用的，但是其中的api都不是很熟。"]}),"\n",(0,a.jsx)(n.p,{children:"antd pro的很多组件封装的都挺好的，使用起来比antd的舒服，但是也存在着过度封装的问题，我以前用proformlist嵌套proformlist的时候就出现了第二层的actionRef失效的问题，每次改第二层的数据，只能从第一层中解构出来，还是很麻烦的（不过也比写俩formlist嵌套要好点。）"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}let i=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["antd-design%2FeditableProTable%2F2.%E6%9C%89%E5%A4%9A%E9%80%89%E7%9A%84select%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%8F%8D%E6%98%BE%E9%97%AE%E9%A2%98.md"]={toc:[],title:"",headingTitle:"",frontmatter:{}}}}]);